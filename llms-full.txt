---
url: /faq/faq.md
---
# 常见问题汇总
## 1、mica-mqtt-spring-boot-starter 空指针 NullPointerException

详细信息： Mqtt server IMqttMessageListener Bean not found

解决方案：IMqttMessageListener 为业务处理，必须要实现的接口。实现该接口并注册成 Spring Bean 即可。

## 2、解码异常

* mqtt 3.1 版协议规定 clientId 范围 1~23, 如果不再此范围会报错，mica-mqtt 服务端提供了 maxClientIdLength 参数，请按需配置。（v2.1.1 开始最大长度默认为 64）
* mica-mqtt 默认的最大包体长度为 8092（v1.3.6 开始默认为 10M），当包体大于这个值时会报异常，mica-mqtt 提供了 maxBytesInMessage 参数，请按需配置。
* mica-mqtt readBufferSize 默认为 8k，最大值可以设置为 132476（130k，受 t-io 限制），t-io 解码会尝试 10 次，也就是最大消息体支持 1.26 M。
* 如果要设置得更大，可以将 mica-mqtt readBufferSize 设置成 0 (v1.3.6 开始支持)，
* 然后在 java 启动变量中添加 `-Dtio.default.read.buffer.size=1048576` (1M，也就是最大支持 10M 消息体，请按需设置)。
* **大量消息，业务处理不赢**会导致解码异常，服务端可设置 `useQueueDecode(true)` 1.3.7 会默认成 true。不过业务一直处理不赢还是会照成更严重的问题。最后队列占满导致 jvm 内存溢出。建议集群并对接 kafka、rocketmq 等。

## 3、NoSuchMethodError: java.nio.ByteBuffer.XXX(I)Ljava/nio/ByteBuffer;

**存在此问题的版本**：`1.0.0`、`1.0.0-RC`、`1.0.3`、`1.0.4`、`2.4.5`
该问题主要是 jar 编译问题，由于 JDK9+ 改了 ByteBuffer 部分返回值的类型，导致 java9+ 下编译的 jar 在 java8 下运行会有问题。如果遇到此问题，请立刻反馈。

## 4、多个客户端使用相同 clientId 导致前者被踢下线（周期性上下线）

* 多个客户端相同 clientId 互踢日志关键字 **准备关闭连接 ... now bind on new context id:\[xxxx]**
* clientId 对于在 mqtt 中起着十分重要的作用，请不要随意设置，建议按照产品、设备、sn等维度生成，并且**确保唯一**。
* 如果实在是要兼容老业务，可以实现 `IMqttServerUniqueIdService` (1.1.4开始支持) 接口，返回的 `uniqueId` 会替代 clientId，后续的场景也是需要使用这个 `uniqueId` 来处理。

## 5、nginx tcp 负载均衡

#### 5.1 搜索关键词 `nginx tcp 负载均衡` 即可：

* https://zhuanlan.zhihu.com/p/139275668
* http://nginx.org/en/docs/stream/ngx\_stream\_proxy\_module.html

#### 5.2 配置 /etc/nginx/nginx.conf，示例:

```
stream {
  upstream stream_backend {
      zone tcp_servers 64k;
      hash $remote_addr;
      server 192.168.0.2:1883 max_fails=2 fail_timeout=30s;
      server 192.168.0.3:1883 max_fails=2 fail_timeout=30s;
  }

  server {
      listen 8883 ssl;
      status_zone tcp_server;
      proxy_pass stream_backend;
      proxy_buffer_size 4k;
      proxy_protocol    on; # 转发源ip信息, mica-mqtt 开源版 2.4.x 正式版开始支持。
      ssl_handshake_timeout 15s;
      ssl_certificate     /etc/emqx/certs/cert.pem;
      ssl_certificate_key /etc/emqx/certs/key.pem;
  }
}
```

## 6、Mqtt 集群

mica-mqtt 1.1.2 版本开始添加了 `mica-mqtt-broker` 模块，采用 redis pub/sub 实现集群，有需求的朋友可以参考。

## 7、SNAPSHOT 版本使用（central sonatype 快照版仅仅存储 90 天，如果有使用需要尽快切到最新的正式版）

**snapshots** 版本会及时响应修复最新的 bug 和需求，dev 分支提交后 Github Action 会自动构建、发布。

**maven:**

```xml
<repositories>
  <repository>
    <name>Central Portal Snapshots</name>
    <id>central-portal-snapshots</id>
    <url>https://central.sonatype.com/repository/maven-snapshots/</url>
    <releases>
      <enabled>false</enabled>
    </releases>
    <snapshots>
      <enabled>true</enabled>
    </snapshots>
  </repository>
</repositories>
```

**gradle:**

```groovy
repositories {
  maven {
    name = 'Central Portal Snapshots'
    url = 'https://central.sonatype.com/repository/maven-snapshots/'

    // Only search this repository for the specific dependency
    content {
      includeModule("<the snapshot's groupId>", "<the snapshot's artifactId>")
    }
  }
  mavenCentral()
}
```

## 8、ssl 证书

**注意**：mica-mqtt 从 v2.3.9 开始支持 PKCS12 证书，mica-mqtt 支持 JKS 和 PKCS12 证书，根据后缀判断。`.jks, .keystore` 文件后缀会识别成为 `JKS` 证书，`.p12 和 .pfx` 会识别成 `PKCS12` 证书。其他默认成 JKS。

**maven** `resources` 拷贝文件是默认会做 `filter`，会导致我们的文件发生变化，导致不能读，`pom` 中你需要添加下面的配置。

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
	<artifactId>maven-resources-plugin</artifactId>
	<configuration>
		<nonFilteredFileExtensions>
			<nonFilteredFileExtension>jks</nonFilteredFileExtension>
			<nonFilteredFileExtension>pfx</nonFilteredFileExtension>
		</nonFilteredFileExtensions>
	</configuration>
</plugin>
```

### 8.1 申请的证书

腾讯云、阿里云等提供有 jks 证书，直接申请下载，记住申请时的密码：
代码中 `.useSsl("classpath:xxx.jks", "classpath:xxx.jks", "密码")` 即可

### 8.2 自签证书（双向认证）

1. 按这个文章生成服务端和客户端证书：https://www.toolhelper.cn/SSL/SSLGenerate 点击下载，解压，拷贝 `generate.pfx` 到项目。
2. 服务端使用 `.useSsl("classpath:generate.pfx", "密码")` 开启 ssl。（v2.3.9 开始支持 .pfx 和 .p12 后缀）
3. 客户端 mqttx 使用如下图：

**将 `generate.pfx` 转成 pem 证书** https://www.toolhelper.cn/SSL/PfxToPem

![输入图片说明](https://foruda.gitee.com/images/1731397117909805034/c878d443_372.png "屏幕截图")

更多教程：openssl自签名证书教程(单域名证书/泛域名证书/多域名证书)详见：https://www.orcy.net.cn/340.html

## 9、服务器配置调优

详见: [**Linux 操作系统参数和TCP 协议栈网络参数**章节](https://www.emqx.io/docs/zh/v3.0/tune.html#linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0)

## 10、Mqtt client 动态更新 clientId，username，password

```java
/**
 * 客户端连接状态监听
 *
 * @author L.cm
 */
@Service
public class MqttClientConnectListener implements IMqttClientConnectListener {
	private static final Logger logger = LoggerFactory.getLogger(MqttClientConnectListener.class);

	@Autowired
	private ApplicationContext applicationContext;

	@Override
	public void onConnected(ChannelContext context, boolean isReconnect) {
		if (isReconnect) {
			logger.info("重连 mqtt 服务器重连成功...");
		} else {
			logger.info("连接 mqtt 服务器成功...");
		}
	}

	@Override
	public void onDisconnect(ChannelContext channelContext, Throwable throwable, String remark, boolean isRemove) {
		logger.error("mqtt 链接断开 remark:{} isRemove:{}", remark, isRemove, throwable);
		// 在断线时更新 clientId、username、password
		MqttClientCreator mqttClientCreator = applicationContext.getBean(MqttClientCreator.class);
		mqttClientCreator
			.clientId("newClient" + System.currentTimeMillis())
			.username("newUserName")
			.password("newPassword");
	}

}
```

## 11、浏览器 mqtt.js websocket 连接

**科普**：浏览器只能走 websocket mqtt 子协议，对应 mica-mqtt **8083** 端口。

**连错端口会报异常，如下：**

```java
org.tio.core.exception.TioDecodeException: java.lang.IllegalArgumentException: invalid QoS: 3
 at net.dreamlu.iot.mqtt.codec.MqttDecoder.doDecode(MqttDecoder.java:67)
```

**mqtt.js websocket 示例：**

```javascript
const clientId = 'mqttjs_' + Math.random().toString(16).substr(2, 8)

const host = 'ws://mqtt.dreamlu.net:8083/mqtt'

const options = {
  keepalive: 60,
  clientId: clientId,
  username: 'mqtt登录用户名',
  password: 'mqtt登录密码',
  protocolId: 'MQTT',
  protocolVersion: 4,
  clean: true,
  reconnectPeriod: 1000,
  connectTimeout: 30 * 1000,
  will: {
    topic: 'WillMsg',
    payload: 'Connection Closed abnormally..!',
    qos: 0,
    retain: false
  },
}

console.log('Connecting mqtt client')
const client = mqtt.connect(host, options)

client.on('error', (err) => {
  console.log('Connection error: ', err)
  client.end()
})

client.on('reconnect', () => {
  console.log('Reconnecting...')
})
```

## 十二、mqtt 心跳超时

* 客户端默认心跳超时 60s
* 服务端默认心跳检测 120s
* 服务端会默认以 1.5倍（keepaliveBackoff \* 2） 客户端心跳超时进行判断，最长周期最长 2.5 倍。（所以客户端实际超时时间为 90s ~ 150s）

**拔网线**等**非正常断开**需要一个心跳检测周期才会触发断开。

对于设备可以监听到下电可以发送 logout topic （子设备）或者 mqtt disconnect 下线指令（直连设备）

## 十三、client、server 同时使用时 caffeine 依赖异常（v）

```java
Failed to instantiate [net.dreamlu.iot.mqtt.core.server.MqttServer]: Factory method 'mqttServer' threw 
exception; nested exception is java.lang.NoClassDefFoundError: 
com/github/benmanes/caffeine/cache/RemovalListener
```

**解决方案：** pom 中将 mqtt server 依赖放 mqtt client 前面。

## 十四、为什么群 突然解散了?

群没啥意义，没啥有用的反馈和意见，git issues 能记录问题，百度权重也很高。

有问题请 gitee 提 issues，**github 的消息太多了也经常好几天才会注意到**，谢谢！

## 十五、问题：拉取 maven 包很慢或拉不了?

注意：如果在 IDEA 设置里指定了 settings.xml，下面两个方案可能会失效。（或者直接拿"腾讯云"或“华为云”或“阿里云” 的镜像仓库地址，按自己的习惯配置）

* 腾讯云： https://mirrors.cloud.tencent.com/nexus/repository/maven-public/
* 华为云：https://mirrors.huaweicloud.com/repository/maven/
* 阿里云：https://maven.aliyun.com/repository/central （这是新地址，旧的不行）

以下以腾讯配置示例。

***1、可以在项目的 pom.xml 添加 "腾讯" 的镜像仓库***

"阿里" 的仓库很难拉取到最新版本的 mica-mqtt 包，所以本案采用 "腾讯" 的镜像仓库进行加速

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!--
     使用时，可以项目的 pom.xml 里添加 repositories 内容
     -->

    <repositories>
        <repository>
            <id>central</id>
            <url>https://mirrors.cloud.tencent.com/nexus/repository/maven-public/</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>
    </repositories>
</project>
```

***2、或者可以在 .m2/settings.xml 添加 "腾讯" 的镜像仓库***

开发工具如果可以为项目选择一个 settings.xml 的，可以选这个文件。

```xml
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                          https://maven.apache.org/xsd/settings-1.0.0.xsd">
  <mirrors>
    <mirror> 
      <id>central</id> 
      <url>https://mirrors.cloud.tencent.com/nexus/repository/maven-public/</url>
      <mirrorOf>central</mirrorOf> 
    </mirror>
  </mirrors>
  
</settings>
```

---

---
url: /guide/index.md
---
# mica mqtt 快速上手
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 普通 Java 程序

* [mica mqtt client 客户端使用文档](java/client.md)
* [mica mqtt server 服务端使用文档](java/server.md)

## Android

* [mica mqtt client Android 原生客户端使用文档](android/client.md)
* [mica mqtt server Android 原生服务端使用文档](android/server.md)

## Spring boot

* [mica-mqtt-client-spring-boot-starter 使用文档](spring/client.md)
* [mica-mqtt-server-spring-boot-starter 使用文档](spring/server.md)

## solon

* [mica-mqtt-client-solon-plugin 使用文档](solon/client.md)
* [mica-mqtt-server-solon-plugin 使用文档](solon/server.md)

## JFinal

* [mica-mqtt-client-jfinal-plugin 使用文档](jfinal/client.md)
* [mica-mqtt-server-jfinal-plugin 使用文档](jfinal/server.md)

---

---
url: /guide/android/client.md
---
# mica mqtt client Android 原生客户端使用文档
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 使用

#### 1. 添加依赖

```groovy
implementation 'org.dromara.mica-mqtt:mica-mqtt-client:$micaMqttVersion' // 使用 2.4.2 或以上版本
```

#### 2. 排除 INDEX.LIST 文件

```groovy
android {
    // ... 其他配置
    packagingOptions {
        // 排除 INDEX.LIST 文件
        exclude 'META-INF/INDEX.LIST'
    }
}
```

#### 3. 客户端使用

```java
// 初始化 mqtt 客户端
MqttClient client = MqttClient.create()
    .ip("127.0.0.1")                // mqtt 服务端 ip 地址
    .port(1883)                     // 默认：1883
    .username("admin")              // 账号
    .password("123456")             // 密码
    .version(MqttVersion.MQTT_5)    // 默认：3_1_1
    .clientId("xxxxxx")             // 非常重要务必手动设置，一般设备 sn 号，默认：MICA-MQTT- 前缀和 36进制的纳秒数
    .readBufferSize(512)            // 消息一起解析的长度，默认：为 8092 （mqtt 消息最大长度）
    .maxBytesInMessage(1024 * 10)   // 最大包体长度,如果包体过大需要设置此参数，默认为： 10M (10*1024*1024)
    .keepAliveSecs(120)             // 默认：60s
    .timeout(10)                    // 超时时间，t-io 配置，可为 null，为 null 时，t-io 默认为 5
    .reconnect(true)                // 是否重连，默认：true
    .reInterval(5000)               // 重连重试时间，reconnect 为 true 时有效，t-io 默认为：5000
    .willMessage(builder -> {
        builder.topic("/test/offline").messageText("down");    // 遗嘱消息
    })
    .connectListener(new IMqttClientConnectListener() {
        @Override
        public void onConnected(ChannelContext context, boolean isReconnect) {
            logger.info("链接服务器成功...");
        }
        
        @Override
        public void onDisconnect(ChannelContext channelContext, Throwable throwable, String remark, boolean isRemove) {
            logger.info("与链接服务器断开连接...");
        }
    })
    .properties()                   // mqtt5 properties
    .connectSync();                 // 同步连接，也可以使用 connect()，可以避免 broker 没启动照成启动卡住。

    // 消息订阅，同类方法 subxxx
    client.subQos0("/test/#", (context, topic, message, payload) -> {
        logger.info(topic + '\t' + new String(payload, StandardCharsets.UTF_8));
    });
    // 取消订阅
    client.unSubscribe("/test/#");

    // 发送消息
    client.publish("/test/client", "mica最牛皮".getBytes(StandardCharsets.UTF_8));

    // 断开连接
    client.disconnect();
    // 重连
    client.reconnect();
    // 停止
    client.stop();
```

![Android启动效果](mica-mqtt-client-android.png)

#### 4. 全局订阅（2.2.9开始支持）

**说明**：由于 mica-mqtt-client 采用传统 mq 的思维进行的开发。其实是跟 mqtt 部分是有违背的。传统 mqtt client 不会按 topic 进行不通的订阅，采用的是这里的**全局订阅**方式。

**注意**：全局订阅也是可以监听到 `subQos0`、`subQos1`、`subQos2` 的消息。采用 `globalSubscribe`，保留 session 停机重启，依然可以接受到消息。

```java
// 初始化 mqtt 客户端
MqttClient.create()
    .ip("127.0.0.1")
    .port(1883)
    .username("admin")
    .password("123456")
    // 采用 globalSubscribe，保留 session 停机重启后，可以接受到离线消息，注意：clientId 要不能变化。
    .clientId("globalTest")
    .cleanSession(false)
    // 全局订阅的 topic
    .globalSubscribe("/test", "/test/123", "/debug/#")
    // 全局监听，也会监听到服务端 http api 订阅的数据
    .globalMessageListener((context, topic, message, payload) -> {
        System.out.println("topic:\t" + topic);
        System.out.println("payload:\t" + ByteBufferUtil.toString(payload));
    })
    .connectSync();
```

---

---
url: /guide/android/server.md
---
# mica mqtt server Android 原生服务端使用文档
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 使用

#### 1. 添加依赖

```groovy
implementation 'org.dromara.mica-mqtt:mica-mqtt-server:$micaMqttVersion' // 使用 2.4.2 或以上版本
```

#### 2. 排除 INDEX.LIST 文件

```groovy
android {
    // ... 其他配置
    packagingOptions {
        // 排除 INDEX.LIST 文件
        exclude 'META-INF/INDEX.LIST'
    }
}
```

#### 3. 服务端使用（2.5.x或以上）

```java
// 注意：为了能接受更多链接（降低内存），请添加 jvm 参数 -Xss129k
MqttServer mqttServer = MqttServer.create()
    // 服务端 ip 默认为空，0.0.0.0，建议不要设置，端口 默认：1883
    .enableMqtt(1883)
    // 默认为： 8192（mqtt 默认最大消息大小），为了降低内存可以减小小此参数，如果消息过大 t-io 会尝试解析多次（建议根据实际业务情况而定）
    .readBufferSize(8192)
//  最大包体长度
//  .maxBytesInMessage(1024 * 100)
//  mqtt 3.1 协议会校验 clientId 长度。
//  .maxClientIdLength(64)
    .messageListener((context, clientId, topic, qos, message) -> {
        logger.info("clientId:{} payload:{}", clientId, new String(message.payload(), StandardCharsets.UTF_8));
    })
    // 客户端连接状态监听
    .connectStatusListener(new MqttConnectStatusListener())
    // 自定义消息拦截器
    .addInterceptor(new MqttMessageInterceptor())
    // 开启 websocket
    .enableMqttWs()
    // 开启 mqtt http 接口
    .enableMqttHttpApi(builder ->
        builder
            .basicAuth("mica", "mica") // http basic 认证
            .mcpServer()               // 开启 mcp 服务
            .build()
    )
    // 开始 stat 监控
    .statEnable()
    // 开启 debug 信息日志
    .debug()
    .start();

// 定时下发消息
mqttServer.schedule(() -> {
    String message = "mica最牛皮 " + System.currentTimeMillis();
    mqttServer.publishAll("/test/123", message.getBytes(StandardCharsets.UTF_8));
}, 2000);

// 2.3.2 开始支持 stop 关闭
// mqttServer.stop();
```

#### 3. 服务端使用（2.4.x或以下）

```java
// 注意：为了能接受更多链接（降低内存），请添加 jvm 参数 -Xss129k
MqttServer mqttServer = MqttServer.create()
    // 服务端 ip 默认为空，0.0.0.0，建议不要设置
    .ip("0.0.0.0")
    // 默认：1883
    .port(1883)
    // 默认为： 8092（mqtt 默认最大消息大小），为了降低内存可以减小小此参数，如果消息过大 t-io 会尝试解析多次（建议根据实际业务情况而定）
    .readBufferSize(512)
    // 最大包体长度，如果包体过大需要设置此参数，默认为： 8092
    .maxBytesInMessage(1024 * 100)
    // 自定义认证
    .authHandler((clientId, userName, password) -> true)
    // 消息监听
    .messageListener((context, clientId, message) -> {
        logger.info("clientId:{} message:{} payload:{}", clientId, message, new String(message.getPayload(), StandardCharsets.UTF_8));
    })
    // 心跳超时时间，默认：120s
    .heartbeatTimeout(120_1000L)
    // ssl 配置
    .useSsl("", "", "")
    // 开启代理协议，支持 nginx 开启 tcp proxy_protocol on; 时转发源 ip 信息。2.4.1 版本开始支持
    .proxyProtocolEnable()
    // 自定义客户端上下线监听
    .connectStatusListener(new IMqttConnectStatusListener() {
        @Override
        public void online(String clientId) {

        }

        @Override
        public void offline(String clientId) {

        }
    })
    // 自定义消息转发，可用 mq 广播实现集群化处理
    .messageDispatcher(new IMqttMessageDispatcher() {
        @Override
        public void config(MqttServer mqttServer) {

        }

        @Override
        public boolean send(Message message) {
            return false;
        }

        @Override
        public boolean send(String clientId, Message message) {
            return false;
        }
    })
    .start();

// 发送给某个客户端
mqttServer.publish("clientId","/test/123", "mica最牛皮".getBytes(StandardCharsets.UTF_8));

// 发送给所有在线监听这个 topic 的客户端
mqttServer.publishAll("/test/123", "mica最牛皮".getBytes(StandardCharsets.UTF_8));

// 停止服务
mqttServer.stop();
```

**注意：** 2.4.4 之前版本请不要开启 `debug`，Android 上没有 `RuntimeMXBean` 会报错（2.4.4 已做兼容处理）。

![Android启动效果](mica-mqtt-server-android.png)

#### 3. 启用混淆，需添加如下配置

```text
-dontwarn cn.hutool.json.**
-dontwarn com.alibaba.fastjson.**
-dontwarn com.alibaba.fastjson2.**
-dontwarn com.fasterxml.jackson.**
-dontwarn com.google.gson.**
-dontwarn org.noear.snack.**
-dontwarn java.lang.management.**
```

#### 4. http 和 websocket 依赖（2.4.3 以前版本需要该步骤）：

开启 http 或 websocket 需要添加 mica-net-http 依赖，如果不需要 http、websocket 把它们可以使用 `.httpEnable(false)` 和 `.websocketEnable(false)` 关掉就不需要该依赖了。

```groovy
implementation 'net.dreamlu:mica-net-http:$micaNetVersion'
```

如何确定 mica-net 的版本？可以打开 idea maven 依赖查看，当前依赖的 `mica-net-core` 版本，请确保跟 `mica-net-core` 使用一样的版本，避免版本兼容问题。

![img.png](img.png)

另外 http api 需要项目带有 jackson、fastjson、fastjson2、gson、hutool-json、snack3（mica-mqtt 2.3.4开始支持） 这些json工具其一。

---

---
url: /guide/httpApi.md
---
# mica mqtt Http Api 接口
**注意：** 从 mica-mqtt 2.5.x 开始默认的 http api 端口由 ~~8083~~ 改为了 `18083`。

### HTTP 状态码 (status codes)

接口在调用成功时总是返回 200 OK，响应内容则以 JSON 格式返回。

可能的状态码如下：

| Status Code | Description                                              |
| ----------- | -------------------------------------------------------- |
| 200         | 成功，返回的 JSON 数据将提供更多信息                     |
| 400         | 客户端请求无效，例如请求体或参数错误                     |
| 401         | 客户端未通过服务端认证，使用无效的身份验证凭据可能会发生 |
| 404         | 找不到请求的路径或者请求的对象不存在                     |
| 405         | 请求方法错误                     						 |
| 500         | 服务端处理请求时发生内部错误                             |

### 返回码 (result codes)

接口的响应消息体为 JSON 格式，其中总是包含返回码 `code`。

可能的返回码如下：

| Return Code | Description                |
| ----------- | -------------------------- |
| 1           | 成功                       |
| 101         | 关键请求参数缺失           |
| 102         | 请求参数错误               |
| 103         | 用户名或密码错误           |
| 104         | 请求方法错误               |
| 105         | 未知错误                   |

## 获取所有 api 接口列表

### GET /api/v1/endpoints

**Success Response Body (JSON):**

| Name | Type    | Description |
| ---- |---------|-------------|
| code | Integer | 1           |
| data | Array   | 接口列表        |
| method | String  | 方法名         |
| path | String  | 路径          |

**Examples:**

```bash
$ curl -i --basic -u mica:mica "http://localhost:18083/api/v1/endpoints"

{
    "data": [
        {
            "method": "GET",
            "path": "/api/v1/endpoints"
        },
        {
            "method": "GET",
            "path": "/api/v1/clients"
        },
        {
            "method": "POST",
            "path": "/api/v1/mqtt/unsubscribe"
        },
        {
            "method": "GET",
            "path": "/api/v1/clients/info"
        },
        {
            "method": "GET",
            "path": "/api/v1/stats"
        },
        {
            "method": "POST",
            "path": "/api/v1/mqtt/publish/batch"
        },
        {
            "method": "POST",
            "path": "/api/v1/mqtt/subscribe/batch"
        },
        {
            "method": "GET",
            "path": "/api/v1/client/subscriptions"
        },
        {
            "method": "POST",
            "path": "/api/v1/mqtt/publish"
        },
        {
            "method": "POST",
            "path": "/api/v1/mqtt/unsubscribe/batch"
        },
        {
            "method": "POST",
            "path": "/api/v1/mqtt/subscribe"
        },
        {
            "method": "POST",
            "path": "/api/v1/clients/delete"
        }
    ],
    "code": 1
}
```

## 消息发布

### POST /api/v1/mqtt/publish

发布 MQTT 消息。

**Parameters (json):**

| Name     | Type    | Required | Default | Description                                    |
| -------- | ------- | -------- | ------- |------------------------------------------------|
| topic    | String  | Required |         | 主题，消息会按 topic 订阅投递                             |
| clientId | String  | Required |         | 客户端标识符，不为空参数即可，无实际意义，建议可以取名 httpApi            |
| payload  | String  | Required |         | 消息正文                                           |
| encoding | String  | Optional | plain   | 消息正文使用的编码方式，目前仅支持 目前仅支持 `plain`、`hex`、`base64` |
| qos      | Integer | Optional | 0       | QoS 等级                                         |
| retain   | Boolean | Optional | false   | 是否为保留消息                                        |

**Success Response Body (JSON):**

| Name | Type    | Description |
| ---- | ------- | ----------- |
| code | Integer | 0           |

**Examples:**

```bash
$ curl -i --basic -u mica:mica -X POST "http://localhost:18083/api/v1/mqtt/publish" -d '{"topic":"a/b/c","payload":"Hello World","qos":1,"retain":false,"clientId":"example"}'

{"code":1}
```

## 主题订阅

### POST /api/v1/mqtt/subscribe

订阅 MQTT 主题。

**Parameters (json):**

| Name     | Type    | Required | Default | Description                                           |
| -------- | ------- | -------- | ------- | ----------------------------------------------------- |
| topic    | String  | Required |         | 主题                                                  |
| clientId | String  | Required |         | 客户端标识符                                          |
| qos      | Integer | Optional | 0       | QoS 等级                                              |

**Success Response Body (JSON):**

| Name | Type    | Description |
| ---- | ------- | ----------- |
| code | Integer | 0           |

**Examples:**

同时订阅 `a`, `b`, `c` 三个主题

```bash
$ curl -i --basic -u mica:mica -X POST "http://localhost:18083/api/v1/mqtt/subscribe" -d '{"topic":"a/b/c","qos":1,"clientId":"example"}'

{"code":1}
```

### POST /api/v1/mqtt/unsubscribe

取消订阅。

**Parameters (json):**

| Name     | Type   | Required | Default | Description  |
| -------- | ------ | -------- | ------- | ------------ |
| topic    | String | Required |         | 主题         |
| clientId | String | Required |         | 客户端标识符 |

**Success Response Body (JSON):**

| Name | Type    | Description |
| ---- | ------- | ----------- |
| code | Integer | 0           |

**Examples:**

取消订阅 `a` 主题

```bash
$ curl -i --basic -u mica:mica -X POST "http://localhost:18083/api/v1/mqtt/unsubscribe" -d '{"topic":"a","clientId":"example"}'

{"code":1}
```

## 消息批量发布

### POST /api/v1/mqtt/publish/batch

批量发布 MQTT 消息。

**Parameters (json):**

| Name         | Type    | Required | Default | Description                              |
| ------------ | ------- | -------- | ------- |------------------------------------------|
| \[0].topic    | String  | Required |         | 主题，消息按订阅投递                               |
| \[0].clientId | String  | Required |         | 客户端标识符，不为空参数即可，无实际意义，建议可以取名 httpApi      |
| \[0].payload  | String  | Required |         | 消息正文                                     |
| \[0].encoding | String  | Optional | plain   | 消息正文使用的编码方式，目前仅支持 `plain`、`hex`、`base64` |
| \[0].qos      | Integer | Optional | 0       | QoS 等级                                   |
| \[0].retain   | Boolean | Optional | false   | 是否为保留消息                                  |

**Success Response Body (JSON):**

| Name | Type    | Description |
| ---- | ------- | ----------- |
| code | Integer | 0           |

**Examples:**

```bash
$ curl -i --basic -u mica:mica -X POST "http://localhost:18083/api/v1/mqtt/publish/batch" -d '[{"topic":"a/b/c","payload":"Hello World","qos":1,"retain":false,"clientId":"example"},{"topic":"a/b/c","payload":"Hello World Again","qos":0,"retain":false,"clientId":"example"}]'

{"code":1}
```

## 主题批量订阅

### POST /api/v1/mqtt/subscribe/batch

批量订阅 MQTT 主题。

**Parameters (json):**

| Name         | Type    | Required | Default | Description                                           |
| ------------ | ------- | -------- | ------- | ----------------------------------------------------- |
| \[0].topic    | String  | Required |         | 主题                                                  |
| \[0].clientId | String  | Required |         | 客户端标识符                                          |
| \[0].qos      | Integer | Optional | 0       | QoS 等级                                              |

**Success Response Body (JSON):**

| Name | Type    | Description |
| ---- | ------- | ----------- |
| code | Integer | 0           |

**Examples:**

一次性订阅 `a`, `b`, `c` 三个主题

```bash
$ curl -i --basic -u mica:mica -X POST "http://localhost:18083/api/v1/mqtt/subscribe/batch" -d '[{"topic":"a","qos":1,"clientId":"example"},{"topic":"b","qos":1,"clientId":"example"},{"topic":"c","qos":1,"clientId":"example"}]'

{"code":1}
```

### POST /api/v1/mqtt/unsubscribe/batch

批量取消订阅。

**Parameters (json):**

| Name         | Type   | Required | Default | Description  |
| ------------ | ------ | -------- | ------- | ------------ |
| \[0].topic    | String | Required |         | 主题         |
| \[0].clientId | String | Required |         | 客户端标识符 |

**Success Response Body (JSON):**

| Name | Type    | Description |
| ---- | ------- | ----------- |
| code | Integer | 0           |

**Examples:**

一次性取消订阅 `a`, `b` 主题

```bash
$ curl -i --basic -u mica:mica -X POST "http://localhost:18083/api/v1/mqtt/unsubscribe/batch" -d '[{"topic":"a","clientId":"example"},{"topic":"b","clientId":"example"}]'

{"code":1}
```

## 获取客户端详情

### GET /api/v1/clients/info

**Query Parameters:**

| Name     | Type   | Required | Description |
| -------- | ------ | -------- | ----------- |
| clientId | String | True     | ClientID    |

**Success Response Body (JSON):**

| Name      | Type    | Description |
|-----------|---------|-------------|
| code      | Integer | 0           |
| clientId  | String  | clientId    |
| username  | String  | 用户名         |
| connected | Boolen  | 是否已经连接      |
| createdAt | Long  | 连接的时间       |
| connectedAt | Long    | 连接成功时间      |

**Examples:**

```bash
$ curl -i --basic -u mica:mica -X POST "http://localhost:18083/api/v1/clients/info?clientId=mqttx_5fe4cfcf"

{"code":1,"data":{"clientId":"mqttx_5fe4cfcf","connected":true,"connectedAt":1681792417835,"createdAt":1681792417835,"ipAddress":"127.0.0.1","port":11852,"protoName":"MQTT","protoVer":5}}
```

## 分页获取客户端

### GET /api/v1/clients

**Query Parameters:**

| Name   | Type | Required | Description  |
|--------|------|----------|--------------|
| \_page  | int  | False    | Page 默认1     |
| \_limit | int  | False    | 分页大小 默认10000 |

**Success Response Body (JSON):**

| Name | Type    | Description |
| ---- | ------- | ----------- |
| code | Integer | 0           |

**Success Response Body (JSON):**

| Name | Type    | Description |
| ---- | ------- |-------------|
| code | Integer | 0           |
| pageNumber | Integer | 当前页码        |
| pageSize | Integer | 分页大小        |
| totalRow | Integer | 分页数         |
| clientId  | String  | clientId    |
| username  | String  | 用户名         |
| connected | Boolen  | 是否已经连接      |
| createdAt | Long  | 连接的时间       |
| connectedAt | Long    | 连接成功时间      |

**Examples:**

```bash
$ curl -i --basic -u mica:mica -X POST "http://localhost:18083/api/v1/clients?_page=1&_limit=100"

{"data":{"list":[{"clientId":"mqttx_5fe4cfcf","connected":true,"protoName":"MQTT","protoVer":5,"ipAddress":"127.0.0.1","port":11852,"connectedAt":1681792417835,"createdAt":1681792417835}],"pageNumber":1,"pageSize":1,"totalRow":1},"code":1}
```

## 踢出指定客户端

### POST /api/v1/clients/delete

踢出指定客户端。注意踢出客户端操作会将连接与会话一并终结。

**Query Parameters:**

| Name     | Type   | Required | Description |
| -------- | ------ | -------- | ----------- |
| clientId | String | True     | ClientID    |

**Success Response Body (JSON):**

| Name | Type    | Description |
| ---- | ------- | ----------- |
| code | Integer | 0           |

**Examples:**

由于客户端可能会重连，所以还会连上了。如果需要永久踢出需要自行开发黑名单。

```bash
$ curl -i --basic -u mica:mica -X POST "http://localhost:18083/api/v1/clients/delete?clientId=123"

{"code":1}
```

## 获取客户端订阅情况

### GET /api/v1/client/subscriptions

获取指定客户端订阅详情。

**Query Parameters:**

| Name     | Type   | Required | Description |
| -------- | ------ | -------- | ----------- |
| clientId | String | True     | ClientID    |

**Success Response Body (JSON):**

| Name | Type    | Description |
| ---- |---------|-------------|
| code | Integer | 0           |
| data | Array   | \[]          |
| topicFilter | String   |             |
| clientId | String  |             |
| mqttQoS | Integer | 0           |

**Examples:**

```bash
$ curl -i --basic -u mica:mica "http://127.0.0.1:8083/api/v1/client/subscriptions?clientId=123"

{
  "code": 1,
  "data": [
    {
      "clientId": "123",
      "mqttQoS": 0,
      "topicFilter": "#"
    },
    {
      "clientId": "123",
      "mqttQoS": 0,
      "topicFilter": "testtopic/#"
    }
  ]
}
```

---

---
url: /guide/java/client.md
---
# mica mqtt client 客户端使用文档
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 使用

#### 1. 添加依赖

```xml
<dependency>
  <groupId>org.dromara.mica-mqtt</groupId>
  <artifactId>mica-mqtt-client</artifactId>
  <version>${mica-mqtt.version}</version>
</dependency>
```

#### 2. 客户端使用

```java
// 初始化 mqtt 客户端
MqttClient client = MqttClient.create()
    .ip("127.0.0.1")                // mqtt 服务端 ip 地址
    .port(1883)                     // 默认：1883
    .username("admin")              // 账号
    .password("123456")             // 密码
    .version(MqttVersion.MQTT_5)    // 默认：3_1_1
    .clientId("xxxxxx")             // 非常重要务必手动设置，一般设备 sn 号，默认：MICA-MQTT- 前缀和 36进制的纳秒数
    .readBufferSize(512)            // 消息一起解析的长度，默认：为 8092 （mqtt 消息最大长度）
    .maxBytesInMessage(1024 * 10)   // 最大包体长度,如果包体过大需要设置此参数，默认为： 10M (10*1024*1024)
    .keepAliveSecs(120)             // 默认：60s
    .timeout(10)                    // 超时时间，t-io 配置，可为 null，为 null 时，t-io 默认为 5
    .reconnect(true)                // 是否重连，默认：true
    .reInterval(5000)               // 重连重试时间，reconnect 为 true 时有效，t-io 默认为：5000
    .willMessage(builder -> {
        builder.topic("/test/offline").messageText("down");    // 遗嘱消息
    })
    .connectListener(new IMqttClientConnectListener() {
        @Override
        public void onConnected(ChannelContext context, boolean isReconnect) {
            logger.info("链接服务器成功...");
        }
        
        @Override
        public void onDisconnect(ChannelContext channelContext, Throwable throwable, String remark, boolean isRemove) {
            logger.info("与链接服务器断开连接...");
        }
    })
    .properties()                   // mqtt5 properties
    .connectSync();                 // 同步连接，也可以使用 connect()，可以避免 broker 没启动照成启动卡住。

    // 消息订阅，同类方法 subxxx
    client.subQos0("/test/#", (context, topic, message, payload) -> {
        logger.info(topic + '\t' + new String(payload, StandardCharsets.UTF_8));
    });
    // 取消订阅
    client.unSubscribe("/test/#");

    // 发送消息
    client.publish("/test/client", "mica最牛皮".getBytes(StandardCharsets.UTF_8));

    // 断开连接
    client.disconnect();
    // 重连
    client.reconnect();
    // 停止
    client.stop();
```

#### 3. 全局订阅（2.2.9开始支持）

**说明**：由于 mica-mqtt-client 采用传统 mq 的思维进行的开发。其实是跟 mqtt 部分是有违背的。传统 mqtt client 不会按 topic 进行不通的订阅，采用的是这里的**全局订阅**方式。

**注意**：全局订阅也是可以监听到 `subQos0`、`subQos1`、`subQos2` 的消息。采用 `globalSubscribe`，保留 session 停机重启，依然可以接受到消息。

```java
// 初始化 mqtt 客户端
MqttClient.create()
    .ip("127.0.0.1")
    .port(1883)
    .username("admin")
    .password("123456")
    // 采用 globalSubscribe，保留 session 停机重启后，可以接受到离线消息，注意：clientId 要不能变化。
    .clientId("globalTest")
    .cleanSession(false)
    // 全局订阅的 topic
    .globalSubscribe("/test", "/test/123", "/debug/#")
    // 全局监听，也会监听到服务端 http api 订阅的数据
    .globalMessageListener((context, topic, message, payload) -> {
        System.out.println("topic:\t" + topic);
        System.out.println("payload:\t" + ByteBufferUtil.toString(payload));
    })
    .connectSync();
```

---

---
url: /guide/java/server.md
---
# mica mqtt server 服务端使用文档
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 使用

#### 1. 添加依赖

```xml
<dependency>
  <groupId>org.dromara.mica-mqtt</groupId>
  <artifactId>mica-mqtt-server</artifactId>
  <version>${mica-mqtt.version}</version>
</dependency>
```

#### 2. 服务端使用（2.5.x或以上）

```java
// 注意：为了能接受更多链接（降低内存），请添加 jvm 参数 -Xss129k
MqttServer mqttServer = MqttServer.create()
    // 服务端 ip 默认为空，0.0.0.0，建议不要设置，端口 默认：1883
    .enableMqtt(1883)
    // 默认为： 8192（mqtt 默认最大消息大小），为了降低内存可以减小小此参数，如果消息过大 t-io 会尝试解析多次（建议根据实际业务情况而定）
    .readBufferSize(8192)
//  最大包体长度
//  .maxBytesInMessage(1024 * 100)
//  mqtt 3.1 协议会校验 clientId 长度。
//  .maxClientIdLength(64)
    .messageListener((context, clientId, topic, qos, message) -> {
        logger.info("clientId:{} payload:{}", clientId, new String(message.payload(), StandardCharsets.UTF_8));
    })
    // 客户端连接状态监听
    .connectStatusListener(new MqttConnectStatusListener())
    // 自定义消息拦截器
    .addInterceptor(new MqttMessageInterceptor())
    // 开启 websocket
    .enableMqttWs()
    // 开启 mqtt http 接口
    .enableMqttHttpApi(builder ->
        builder
            .basicAuth("mica", "mica") // http basic 认证
            .mcpServer()               // 开启 mcp 服务
            .build()
    )
    // 开始 stat 监控
    .statEnable()
    // 开启 debug 信息日志
    .debug()
    .start();

// 定时下发消息
mqttServer.schedule(() -> {
    String message = "mica最牛皮 " + System.currentTimeMillis();
    mqttServer.publishAll("/test/123", message.getBytes(StandardCharsets.UTF_8));
}, 2000);

// 2.3.2 开始支持 stop 关闭
// mqttServer.stop();
```

#### 2. 服务端使用（2.4.x或以下）

```java
// 注意：为了能接受更多链接（降低内存），请添加 jvm 参数 -Xss129k
MqttServer mqttServer = MqttServer.create()
    // 服务端 ip 默认为空，0.0.0.0，建议不要设置
    .ip("0.0.0.0")
    // 默认：1883
    .port(1883)
    // 默认为： 8092（mqtt 默认最大消息大小），为了降低内存可以减小小此参数，如果消息过大 t-io 会尝试解析多次（建议根据实际业务情况而定）
    .readBufferSize(512)
    // 最大包体长度，如果包体过大需要设置此参数，默认为： 8092
    .maxBytesInMessage(1024 * 100)
    // 自定义认证
    .authHandler((clientId, userName, password) -> true)
    // 消息监听
    .messageListener((context, clientId, message) -> {
        logger.info("clientId:{} message:{} payload:{}", clientId, message, new String(message.getPayload(), StandardCharsets.UTF_8));
    })
    // 心跳超时时间，默认：120s
    .heartbeatTimeout(120_1000L)
    // ssl 配置
    .useSsl("", "", "")
    // 开启代理协议，支持 nginx 开启 tcp proxy_protocol on; 时转发源 ip 信息。2.4.1 版本开始支持
    .proxyProtocolEnable()
    // 自定义客户端上下线监听
    .connectStatusListener(new IMqttConnectStatusListener() {
        @Override
        public void online(String clientId) {

        }

        @Override
        public void offline(String clientId) {

        }
    })
    // 自定义消息转发，可用 mq 广播实现集群化处理
    .messageDispatcher(new IMqttMessageDispatcher() {
        @Override
        public void config(MqttServer mqttServer) {

        }

        @Override
        public boolean send(Message message) {
            return false;
        }

        @Override
        public boolean send(String clientId, Message message) {
            return false;
        }
    })
    .debug() // 开启 debug 信息日志
    .start();

// 发送给某个客户端
mqttServer.publish("clientId","/test/123", "mica最牛皮".getBytes(StandardCharsets.UTF_8));

// 发送给所有在线监听这个 topic 的客户端
mqttServer.publishAll("/test/123", "mica最牛皮".getBytes(StandardCharsets.UTF_8));

// 停止服务
mqttServer.stop();
```

#### 3. http 和 websocket 依赖（2.4.2或之前版本需要该步骤）：

开启 http 或 websocket 需要添加 mica-net-http 依赖，如果不需要 http、websocket 把它们可以使用 `.httpEnable(false)` 和 `.websocketEnable(false)` 关掉就不需要该依赖了。

```xml
<dependency>
    <groupId>net.dreamlu</groupId>
    <artifactId>mica-net-http</artifactId>
    <version>${mica-net.version}</version>
</dependency>
```

如何确定 mica-net 的版本？可以打开 idea maven 依赖查看，当前依赖的 `mica-net-core` 版本，请确保跟 `mica-net-core` 使用一样的版本，避免版本兼容问题。

![img.png](img.png)

另外 http api 需要项目带有 jackson2、jackson3（mica-mqtt 2.5.5 开始支持）、fastjson、fastjson2、gson、hutool-json、snack3（mica-mqtt 2.3.4开始支持） 这些json工具其一。

---

---
url: /guide/jfinal/client.md
---
# mica-mqtt-client-jfinal-plugin 使用文档
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 使用

#### 1. 添加依赖

```xml
<dependency>
    <groupId>org.dromara.mica-mqtt</groupId>
    <artifactId>mica-mqtt-client-jfinal-plugin</artifactId>
    <version>${最新版本}</version>
</dependency>
```

#### 2. 删除 jfinal-demo 中的 slf4j-nop 依赖

#### 3. 添加 slf4j-log4j12

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
    <version>1.7.33</version>
</dependency>
```

#### 4. 在 jfinal Config configPlugin 中添加 mica-mqtt client 插件

```java
MqttClientPlugin mqttClientPlugin = new MqttClientPlugin();
mqttClientPlugin.config(mqttClientCreator -> {
	// 设置 mqtt 连接配置信息
	mqttClientCreator
			.clientId("clientId") // 按需配置，相同的会互踢
			.ip("mqtt.dreamlu.net")
			.port(1883)
			.connectListener(Aop.get(MqttClientConnectListener.class));
});
me.add(mqttClientPlugin);
```

#### 5. 在 jfinal Config onStart 启动完成之后添加 mqtt 订阅

```java
@Override
public void onStart() {
    IMqttClientMessageListener clientMessageListener = Aop.get(TestMqttClientMessageListener.class);
    MqttClientKit.subQos0("#", clientMessageListener);
}
```

#### 6. 使用 MqttClientKit 发送消息

```java
MqttClientKit.publish("mica", "hello".getBytes(StandardCharsets.UTF_8));
```

### 7. 示例代码 MqttClientConnectListener

```java
public class MqttClientConnectListener implements IMqttClientConnectListener {

    @Override
    public void onConnected(ChannelContext channelContext, boolean isReconnect) {
        if (isReconnect) {
            System.out.println("重连 mqtt 服务器重连成功...");
        } else {
            System.out.println("连接 mqtt 服务器成功...");
        }
    }

    @Override
    public void onDisconnect(ChannelContext channelContext, Throwable throwable, String remark, boolean isRemove) {
        System.out.println("mqtt 链接断开 remark:" + remark + " isRemove:" + isRemove);
    }
}
```

### 8. 示例 TestMqttClientMessageListener

```java
public class TestMqttClientMessageListener implements IMqttClientMessageListener {
    @Override
    public void onMessage(String topic, MqttPublishMessage message, byte[] payload) {
        System.out.println("收到消息 topic:" + topic + "内容:\n" + new String(payload, StandardCharsets.UTF_8));
    }
}
```

---

---
url: /guide/jfinal/server.md
---
# mica-mqtt-server-jfinal-plugin 使用文档
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 使用

#### 1. 添加依赖

```xml
<dependency>
    <groupId>org.dromara.mica-mqtt</groupId>
    <artifactId>mica-mqtt-server-jfinal-plugin</artifactId>
    <version>${最新版本}</version>
</dependency>
```

#### 2. 删除 jfinal-demo 中的 slf4j-nop 依赖

#### 3. 添加 slf4j-log4j12

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
    <version>1.7.33</version>
</dependency>
```

#### 4. 插件配置（2.5.x或以上）

```java
MqttServerPlugin plugin = new MqttServerPlugin();
plugin.config(mqttServerCreator -> {
    // mqttServerCreator 上有很多方法，详见 mica-mqtt-core
    mqttServerCreator.enableMqtt(1883).enableMqttWs();
});
```

#### 4. 插件配置（2.4.x或以下）

```java
MqttServerPlugin plugin = new MqttServerPlugin();
plugin.config(mqttServerCreator -> {
    // mqttServerCreator 上有很多方法，详见 mica-mqtt-core
    mqttServerCreator.port(1883).webPort(8083).websocketEnable(true);
});
```

#### 5. 插件使用

```java
// 更多方法可以直接使用 MqttServerKit 点出来
MqttServerKit.publish(String clientId, String topic, byte[] payload);
```

---

---
url: /guide/mcp.md
---
# mica mqtt 大模型 MCP
### 配置

![mica-mqtt-mcp-config.png](/assets/image/mica-mqtt-mcp-config.png)

注意：请求头添加的是 mica-mqtt-server 的 http api 默认的 basic 认证的密钥。

### 工具

![mica-mqtt-mcp-tools.png](/assets/image/mica-mqtt-mcp-tools.png)

注意：mica-mqtt-server mcp 目前内置了 mqtt 状态和 mqtt 发布2个 tools 工具，未来会添加更多。

## 效果

![mica-mqtt-mcp-test1.png](/assets/image/mica-mqtt-mcp-test1.png)

![mica-mqtt-mcp-test2.png](/assets/image/mica-mqtt-mcp-test2.png)

---

---
url: /guide/solon/client.md
---
# mica-mqtt-client-solon-plugin 使用文档
本插件基于 https://gitee.com/peigenlpy/mica-mqtt-solon-plugin 调整合并到官方（已经过作者同意）。

## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 版本兼容

| 要求  | Solon 版本 |
|-----|-------|
| 最高  | 3.x   |
| 最低  | 2.8.0 |

## 一、添加依赖

```xml
<dependency>
    <groupId>org.dromara.mica-mqtt</groupId>
    <artifactId>mica-mqtt-client-solon-plugin</artifactId>
    <version>${version}</version>
</dependency>
```

## 二、mqtt 客户端

### 2.1 配置项示例

```yaml
mqtt:
  client:
    enabled: true               # 是否开启客户端，默认：true
    ip: 127.0.0.1               # 连接的服务端 ip ，默认：127.0.0.1
    port: 1883                  # 端口：默认：1883
    name: Mica-Mqtt-Client      # 名称，默认：Mica-Mqtt-Client
    clientId: 000001            # 客户端Id（非常重要，一般为设备 sn，不可重复）
    username: mica             # 认证的用户名，注意：2.5.x 之前是 user-name
    password: 123456            # 认证的密码
    timeout: 5                  # 超时时间，单位：秒，默认：5秒
    reconnect: true             # 是否重连，默认：true
    re-interval: 5000           # 重连时间，默认 5000 毫秒
    version: mqtt_3_1_1         # mqtt 协议版本，可选 MQTT_3_1、mqtt_3_1_1、mqtt_5，默认：mqtt_3_1_1
    read-buffer-size: 8KB       # 接收数据的 buffer size，默认：8k
    max-bytes-in-message: 10MB  # 消息解析最大 bytes 长度，默认：10M
    buffer-allocator: heap      # 堆内存和堆外内存，默认：堆内存
    keep-alive-secs: 60         # keep-alive 时间，单位：秒
    heartbeat-mode: LAST_REQ    # 心跳模式，支持最后发送或接收心跳时间来计算心跳，默认：最后发送心跳的时间。（2.4.3 开始支持）
    heartbeat-timeout-strategy: PING # 心跳超时策略，支持发送 PING 和 CLOSE 断开连接，默认：最大努力发送 PING。（2.4.3 开始支持）
    clean-start: true           # session 保留 2.5.x 使用 clean-start，老版本用 clean-session，默认：true
    session-expiry-interval-secs: 0 # 开启保留 session 时，session 的有效期，默认：0（2.4.2 开始支持）
    biz-thread-pool-size: 2     # mqtt 工作线程数，默认：2，如果消息量比较大，处理较慢，例如做 emqx 的转发消息处理，可以调大此参数（2.4.2 开始支持）
    ssl:
      enabled: false            # 是否开启 ssl 认证，2.1.0 开始支持双向认证
      keystore-path:            # 可选参数：ssl 双向认证 keystore 目录，支持 classpath:/ 路径。
      keystore-pass:            # 可选参数：ssl 双向认证 keystore 密码
      truststore-path:          # 可选参数：ssl 双向认证 truststore 目录，支持 classpath:/ 路径。
      truststore-pass:          # 可选参数：ssl 双向认证 truststore 密码
```

注意：**ssl** 存在三种情况

| 服务端开启ssl                            | 客户端                                        |
| ---------------------------------------- | --------------------------------------------- |
| ClientAuth 为 NONE（不需要客户端验证）   | 仅仅需要开启 ssl 即可不用配置证书             |
| ClientAuth 为 OPTIONAL（与客户端协商）   | 需开启 ssl 并且配置 truststore 证书           |
| ClientAuth 为 REQUIRE (必须的客户端验证) | 需开启 ssl 并且配置 truststore、 keystore证书 |

### 2.2 可实现接口（注册成 Solon Bean 即可）

| 接口                           | 是否必须 | 说明                        |
| ---------------------------   |------| ------------------------- |
| IMqttClientConnectListener    | 否    | 客户端连接成功监听            |

### 2.3 客户端上下线监听

使用 Solon event 解耦客户端上下线监听，注意： 会跟自定义的 `IMqttClientConnectListener` 实现冲突，取一即可。

```java
@Component
public class MqttClientConnectedListener implements EventListener<MqttConnectedEvent> {
    private static final Logger logger = LoggerFactory.getLogger(MqttClientConnectedListener.class);

    @Inject
    private MqttClientCreator mqttClientCreator;

    @Override
    public void onEvent(MqttConnectedEvent mqttConnectedEvent) throws Throwable {
        logger.info("MqttConnectedEvent:{}", mqttConnectedEvent);
    }
}
```

```java
@Component
public class MqttClientDisconnectListener implements EventListener<MqttDisconnectEvent> {
	private static final Logger logger = LoggerFactory.getLogger(MqttClientDisconnectListener.class);

	@Inject
	private MqttClientCreator mqttClientCreator;

	@Override
	public void onEvent(MqttDisconnectEvent mqttDisconnectEvent) throws Throwable {
			logger.info("MqttDisconnectEvent:{}", mqttDisconnectEvent);
			// 在断线时更新 clientId、username、password
			mqttClientCreator.clientId("newClient" + System.currentTimeMillis())
				.username("newUserName")
				.password("newPassword");
	}
}

```

### 2.4 自定义 java 配置（可选）

```java
@Configuration
public class MqttClientCustomizerConfiguration {

	@Bean
	public MqttClientCustomizer mqttClientCustomizer() {
		return new MqttClientCustomizer() {
			@Override
			public void customize(MqttClientCreator creator) {
				// 此处可自定义配置 creator，会覆盖 yml 中的配置
				System.out.println("----------------MqttServerCustomizer-----------------");
			}
		};
	}

}
```

### 2.5 订阅示例

```java
/**
 * 客户端消息监听
 */
@Component
public class MqttClientSubscribeListener {
    private static final Logger logger = LoggerFactory.getLogger(MqttClientSubscribeListener.class);

    @MqttClientSubscribe("/test/#")
    public void subQos0(String topic, byte[] payload) {
        logger.info("subQos0,topic:{} payload:{}", topic, new String(payload, StandardCharsets.UTF_8));
    }

    @MqttClientSubscribe(value = "/qos1/#", qos = MqttQoS.AT_LEAST_ONCE)
    public void subQos1(String topic, byte[] payload) {
        logger.info("topic:{} payload:{}", topic, new String(payload, StandardCharsets.UTF_8));
    }

    @MqttClientSubscribe("/sys/${productKey}/${deviceName}/thing/sub/register")
    public void thingSubRegister(String topic, byte[] payload) {
        // 1.3.8 开始支持，@MqttClientSubscribe 注解支持 ${} 变量替换，会默认替换成 +
        // 注意：mica-mqtt 会先从 Spring boot 配置中替换参数 ${}，如果存在配置会优先被替换。
        logger.info("topic:{} payload:{}", topic, new String(payload, StandardCharsets.UTF_8));
    }

}
```

```java
/**
 * 客户端消息监听的另一种方式
 */
@MqttClientSubscribe("${topic1}")
public class MqttClientMessageListener implements IMqttClientMessageListener {
	private static final Logger logger = LoggerFactory.getLogger(MqttClientMessageListener.class);

	@Override
	public void onMessage(ChannelContext context, String topic, MqttPublishMessage message, byte[] payload) {
		logger.info("MqttClientMessageListener,topic:{} payload:{}", topic, new String(payload, StandardCharsets.UTF_8));
	}
}
```

### 2.6 共享订阅 topic 说明

mica-mqtt client 支持**两种共享订阅**方式：

1. 共享订阅：订阅前缀 `$queue/`，多个客户端订阅了 `$queue/topic`，发布者发布到topic，则只有一个客户端会接收到消息。
2. 分组订阅：订阅前缀 `$share/<group>/`，组客户端订阅了`$share/group1/topic`、`$share/group2/topic`..，发布者发布到topic，则消息会发布到每个group中，但是每个group中只有一个客户端会接收到消息。

### 2.8 MqttClientTemplate 使用示例

```java
@Component
public class ClientService {
    private static final Logger             logger = LoggerFactory.getLogger(ClientService.class);
    @Inject
    private              MqttClientTemplate client;

    public boolean publish(String body) {
        client.publish("/test/client", body.getBytes(StandardCharsets.UTF_8));
        return true;
    }

    public boolean sub() {
        client.subQos0("/test/#", (context, topic, message, payload) -> {
            logger.info(topic + '\t' + new String(payload, StandardCharsets.UTF_8));
        });
        return true;
    }

}
```

---

---
url: /guide/solon/server.md
---
本插件基于 https://gitee.com/peigenlpy/mica-mqtt-solon-plugin 调整合并到官方（已经过作者同意）。

## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 版本兼容

| 要求  | Solon 版本 |
|-----|-----------|
| 最高  | 3.x   |
| 最低  | 2.8.0 |

## 一、添加依赖

```xml
<dependency>
    <groupId>org.dromara.mica-mqtt</groupId>
    <artifactId>mica-mqtt-server-solon-plugin</artifactId>
    <version>${version}</version>
</dependency>
```

## 二、mqtt 服务

### 2.1 配置项（2.5.x或以上）

```yaml
# mqtt 服务端配置
mqtt:
  server:
    enabled: true               # 是否开启服务端，默认：true
    name: Mica-Mqtt-Server      # 名称，默认：Mica-Mqtt-Server
    heartbeat-timeout: 120000   # 心跳超时，单位毫秒，默认: 1000 * 120
    read-buffer-size: 8KB       # 接收数据的 buffer size，默认：8k
    max-bytes-in-message: 10MB  # 消息解析最大 bytes 长度，默认：10M
    auth:
      enable: false             # 是否开启 mqtt 认证
      username: mica            # mqtt 认证用户名
      password: mica            # mqtt 认证密码
    debug: true                 # 如果开启 prometheus 指标收集建议关闭
    stat-enable: true           # 开启指标收集，debug 和 prometheus 开启时需要打开，默认开启，关闭节省内存
    mqtt-listener:              # mqtt 监听器
      enable: true              # 是否开启，默认：false
#      ip: "0.0.0.0"            # 服务端 ip 默认为空，0.0.0.0，建议不要设置
      port: 1883                # 端口，默认：1883
    mqtt-ssl-listener:          # mqtt ssl 监听器
      enable: false             # 是否开启，默认：false
      port: 8883                # 端口，默认：8883
      ssl:                      # ssl 配置，必须
        keystore-path:          # 必须参数：ssl keystore 目录，支持 classpath:/ 路径。
        keystore-pass:          # 必选参数：ssl keystore 密码
        truststore-path:        # 可选参数：ssl 双向认证 truststore 目录，支持 classpath:/ 路径。
        truststore-pass:        # 可选参数：ssl 双向认证 truststore 密码
        client-auth: none       # 是否需要客户端认证（双向认证），默认：NONE（不需要）
    ws-listener:                # websocket mqtt 监听器
      enable: true              # 是否开启，默认：false
      port: 8083                # websocket 端口，默认：8083
    wss-listener:               # websocket ssl mqtt 监听器
      enable: false             # 是否开启，默认：false
      port: 8084                # 端口，默认：8084
      ssl:                      # ssl 配置，必须
        keystore-path:          # 必须参数：ssl keystore 目录，支持 classpath:/ 路径。
        keystore-pass:          # 必选参数：ssl keystore 密码
        truststore-path:        # 可选参数：ssl 双向认证 truststore 目录，支持 classpath:/ 路径。
        truststore-pass:        # 可选参数：ssl 双向认证 truststore 密码
        client-auth: none       # 是否需要客户端认证（双向认证），默认：NONE（不需要）
    http-listener:
      enable: true
      port: 18083
      basic-auth:               # 基础认证
        enable: true
        username: mica
        password: mica
      mcp-server:               # 大模型 mcp
        enable: true
```

### 2.1 配置项（2.4.x或以下）

```yaml
mqtt:
  server:
    enabled: true               # 是否开启服务端，默认：true
#    ip: 0.0.0.0                # 服务端 ip 默认为空，0.0.0.0，建议不要设置
    port: 1883                  # 端口，默认：1883
    name: Mica-Mqtt-Server      # 名称，默认：Mica-Mqtt-Server
    buffer-allocator: HEAP      # 堆内存和堆外内存，默认：堆内存
    heartbeat-timeout: 120000   # 心跳超时，单位毫秒，默认: 1000 * 120
    read-buffer-size: 8KB       # 接收数据的 buffer size，默认：8k
    max-bytes-in-message: 10MB  # 消息解析最大 bytes 长度，默认：10M
    auth:
      enable: false             # 是否开启 mqtt 认证
      username: mica            # mqtt 认证用户名
      password: mica            # mqtt 认证密码
    debug: true                 # 如果开启 prometheus 指标收集建议关闭
    stat-enable: true           # 开启指标收集，debug 和 prometheus 开启时需要打开，默认开启，关闭节省内存
    proxy-protocol-enable: false   # 代理协议支持，nginx 可开启 tcp proxy_protocol on; 时转发源 ip 信息。2.4.1 版本开始支持
    web-port: 8083              # http、websocket 端口，默认：8083
    websocket-enable: true      # 是否开启 websocket，默认： true
    http-enable: false          # 是否开启 http api，默认： false
    http-basic-auth:
      enable: false             # 是否开启 http basic auth，默认： false
      username: mica            # http basic auth 用户名
      password: mica            # http basic auth 密码
    ssl:                        # mqtt tcp ssl 认证
      enabled: false            # 是否开启 ssl 认证，2.1.0 开始支持双向认证
      keystore-path:            # 必须参数：ssl keystore 目录，支持 classpath:/ 路径。
      keystore-pass:            # 必选参数：ssl keystore 密码
      truststore-path:          # 可选参数：ssl 双向认证 truststore 目录，支持 classpath:/ 路径。
      truststore-pass:          # 可选参数：ssl 双向认证 truststore 密码
      client-auth: none         # 是否需要客户端认证（双向认证），默认：NONE（不需要）
```

注意：**ssl** 存在三种情况

| 服务端开启ssl                            | 客户端                                        |
| ---------------------------------------- | --------------------------------------------- |
| ClientAuth 为 NONE（不需要客户端验证）   | 仅仅需要开启 ssl 即可不用配置证书             |
| ClientAuth 为 OPTIONAL（与客户端协商）   | 需开启 ssl 并且配置 truststore 证书           |
| ClientAuth 为 REQUIRE (必须的客户端验证) | 需开启 ssl 并且配置 truststore、 keystore证书 |

### 2.2 可实现接口（注册成 Solon Bean 即可）

| 接口                            | 是否必须       | 说明                                            |
|-------------------------------|------------|-----------------------------------------------|
| IMqttServerUniqueIdService    | 否          | 用于 clientId 不唯一时，自定义实现唯一标识，后续接口使用它替代 clientId |
| IMqttServerAuthHandler        | 是          | 用于服务端认证                                       |
| IMqttServerSubscribeValidator | 否（建议实现）    | 1.1.3 新增，用于对客户端订阅校验                           |
| IMqttServerPublishPermission  | 否（建议实现）    | 1.2.2 新增，用于对客户端发布权限校验                         |
| IMqttMessageListener          | 否（1.3.x为否） | 消息监听                                          |
| IMqttConnectStatusListener    | 是          | 连接状态监听                                        |
| IMqttSessionManager           | 否          | session 管理                                    |
| IMqttSessionListener          | 否          | session 监听                                    |
| IMqttMessageStore             | 集群是，单机否    | 遗嘱和保留消息存储                                     |
| AbstractMqttMessageDispatcher | 集群是，单机否    | 消息转发，（遗嘱、保留消息转发）                              |
| IpStatListener                | 否          | t-io ip 状态监听                                  |
| IMqttMessageInterceptor       | 否          | 消息拦截器，1.3.9 新增                                |

### 2.3 `MqttServerFunction` 注解监听客户端上传的消息使用示例（v2.5.3开始支持）

```java
/**
 *  注解消息监听，注意：如果自行实现了 IMqttMessageListener，MqttServerFunction 注解就不生效了。
 */
@Slf4j
@Service
public class MqttServerMessageListener {

	/**
	 * MQTT消息处理函数
	 *
	 * @param topic mqtt Topic
	 * @param user  订阅消息的负载内容，默认 json 序列化
	 */
	@MqttServerFunction("/test/object")
	public void func1(String topic, User<?> user) {
		log.info("topic:{} user:{}", topic, user);
	}

	@MqttServerFunction("/test/client")
	public void func2(String topic, byte[] message) {
		log.info("topic:{} message:{}", topic, new String(message));
	}

	/**
	 * MQTT消息处理函数，匹配 mqtt Topic /test/+，如何需要匹配所以消息，请使用通配符 #
	 *
	 * @param context        ChannelContext，可选参数
	 * @param topic          实际接收到消息的主题名称，可选参数
	 * @param publishMessage 完整的MQTT发布消息对象，包含消息头和负载，可选参数
	 * @param message        消息负载内容，以字节数组形式提供，可选参数，也可支持对象形式，默认 json 序列化
	 */
	@MqttServerFunction("/test/${xxxx}")
	public void func3(ChannelContext context, String topic, MqttPublishMessage publishMessage, byte[] message) {
		// 获取客户端节点信息
		Node clientNode = context.getClientNode();
		// 记录接收到的MQTT消息信息
		log.info("clientNode:{} topic:{} publishMessage:{} message:{}", clientNode, topic, publishMessage, new String(message));
	}

}
```

### 2.3 传统 IMqttMessageListener (用于监听客户端上传的消息) 使用示例

```java
@Component
public class MqttServerMessageListener implements IMqttMessageListener {
   private static final Logger logger = LoggerFactory.getLogger(MqttServerMessageListener.class);

    @Override
    public void onMessage(ChannelContext context, String clientId, String topic, MqttQoS qoS, MqttPublishMessage message) {
        log.info("clientId:{} message:{} payload:{}", clientId, message, new String(message.getPayload(), StandardCharsets.UTF_8));
    }
}
```

### 2.4 自定义配置（可选）

```java
@Configuration
public class MqttServerCustomizerConfiguration {

	@Bean
	public MqttServerCustomizer mqttServerCustomizer() {
		return new MqttServerCustomizer() {
			@Override
			public void customize(MqttServerCreator creator) {
				// 此处可自定义配置 creator，会覆盖 yml 中的配置
				System.out.println("----------------MqttServerCustomizer-----------------");
			}
		};
	}

}
```

### 2.5 MqttServerTemplate 使用示例

```java
@Component
public class ServerService {
   @Inject
   private MqttServerTemplate server;

   public boolean publish(String body) {
      server.publishAll("/test/123", body.getBytes(StandardCharsets.UTF_8));
      return true;
   }
}
```

### 2.6 客户端上下线监听

使用 Solon event 解耦客户端上下线监听，注意：会跟自定义的 `IMqttConnectStatusListener` 实现冲突，取一种即可。

```java
@Component
public class MqttConnectOfflineListener implements EventListener<MqttClientOfflineEvent> {
   private static final Logger logger = LoggerFactory.getLogger(MqttConnectOfflineListener.class);

   @Override
   public void onEvent(MqttClientOfflineEvent mqttClientOfflineEvent) throws Throwable {
      logger.info("MqttClientOnlineEvent:{}", mqttClientOfflineEvent);
   }
}
```

```java
@Component
public class MqttConnectOnlineListener implements EventListener<MqttClientOnlineEvent> {
	private static final Logger logger = LoggerFactory.getLogger(MqttConnectOnlineListener.class);

	@Override
	public void onEvent(MqttClientOnlineEvent mqttClientOnlineEvent) throws Throwable {
		logger.info("MqttClientOnlineEvent:{}", mqttClientOnlineEvent);
	}
}
```

---

---
url: /guide/spring/client.md
---
# mica-mqtt-client-spring-boot-starter 使用文档
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 版本兼容

| 要求  | Spring boot 版本 |
|-----|----------------|
| 最高  | 4.x            |
| 最低  | 2.1.0.RELEASE  |

## 一、添加依赖

```xml
<dependency>
    <groupId>org.dromara.mica-mqtt</groupId>
    <artifactId>mica-mqtt-client-spring-boot-starter</artifactId>
    <version>${最新版本}</version>
</dependency>
```

## 二、mqtt 客户端

### 2.1 配置项示例

```yaml
mqtt:
  client:
    enabled: true               # 是否开启客户端，默认：true
    ip: 127.0.0.1               # 连接的服务端 ip ，默认：127.0.0.1
    port: 1883                  # 端口：默认：1883
    name: Mica-Mqtt-Client      # 名称，默认：Mica-Mqtt-Client
    client-id: 000001           # 客户端Id（非常重要，一般为设备 sn，不可重复）
    username: mica              # 认证的用户名，注意：2.5.x 之前是 user-name
    password: 123456            # 认证的密码
    global-subscribe:           # 全局订阅的 topic，可被全局监听到，保留 session 停机重启，依然可以接受到消息。（2.2.9开始支持）
    timeout: 5                  # 超时时间，单位：秒，默认：5秒
    reconnect: true             # 是否重连，默认：true
    re-interval: 5000           # 重连时间，默认 5000 毫秒
    version: mqtt_3_1_1         # mqtt 协议版本，可选 MQTT_3_1、mqtt_3_1_1、mqtt_5，默认：mqtt_3_1_1
    read-buffer-size: 8KB       # 接收数据的 buffer size，默认：8k
    max-bytes-in-message: 10MB  # 消息解析最大 bytes 长度，默认：10M
    keep-alive-secs: 60         # keep-alive 时间，单位：秒
    heartbeat-mode: LAST_REQ    # 心跳模式，支持最后发送或接收心跳时间来计算心跳，默认：最后发送心跳的时间。（2.4.3 开始支持）
    heartbeat-timeout-strategy: PING # 心跳超时策略，支持发送 PING 和 CLOSE 断开连接，默认：最大努力发送 PING。（2.4.3 开始支持）
    clean-start: true           # session 保留 2.5.x 使用 clean-start，老版本用 clean-session，默认：true
    session-expiry-interval-secs: 0 # 开启保留 session 时，session 的有效期，默认：0（2.4.2 开始支持）
    biz-thread-pool-size: 2     # mqtt 工作线程数，默认：2，如果消息量比较大，处理较慢，例如做 emqx 的转发消息处理，可以调大此参数（2.4.2 开始支持）
    ssl:
      enabled: false            # 是否开启 ssl 认证，2.1.0 开始支持双向认证
      keystore-path:            # 可选参数：ssl 双向认证 keystore 目录，支持 classpath:/ 路径。
      keystore-pass:            # 可选参数：ssl 双向认证 keystore 密码
      truststore-path:          # 可选参数：ssl 双向认证 truststore 目录，支持 classpath:/ 路径。
      truststore-pass:          # 可选参数：ssl 双向认证 truststore 密码
```

注意：**ssl** 存在三种情况

| 服务端开启ssl                            | 客户端                                        |
| ---------------------------------------- | --------------------------------------------- |
| ClientAuth 为 NONE（不需要客户端验证）   | 仅仅需要开启 ssl 即可不用配置证书             |
| ClientAuth 为 OPTIONAL（与客户端协商）   | 需开启 ssl 并且配置 truststore 证书           |
| ClientAuth 为 REQUIRE (必须的客户端验证) | 需开启 ssl 并且配置 truststore、 keystore证书 |

### 2.2 可实现接口（注册成 Spring Bean 即可）

| 接口                           | 是否必须 | 说明                             |
| ---------------------------   |------|--------------------------------|
| IMqttClientConnectListener    | 否    | 客户端连接成功监听                      |
| IMqttClientGlobalMessageListener    | 否    | 全局消息监听，可以监听到所有订阅消息。（2.2.9开始支持） |

### 2.3 客户端上下线监听

使用 Spring event 解耦客户端上下线监听，注意： `1.3.4` 开始支持。会跟自定义的 `IMqttClientConnectListener` 实现冲突，取一即可。

```java
/**
 * 示例：客户端连接状态监听
 *
 * @author L.cm
 */
@Service
public class MqttClientConnectListener {
    private static final Logger logger = LoggerFactory.getLogger(MqttClientConnectListener.class);

    @Autowired
    private MqttClientCreator mqttClientCreator;

    @EventListener
    public void onConnected(MqttConnectedEvent event) {
        logger.info("MqttConnectedEvent:{}", event);
    }

    @EventListener
    public void onDisconnect(MqttDisconnectEvent event) {
        // 离线时更新重连时的密码，适用于类似阿里云 mqtt clientId 连接带时间戳的方式 
        logger.info("MqttDisconnectEvent:{}", event);
        // 在断线时更新 clientId、username、password
        mqttClientCreator.clientId("newClient" + System.currentTimeMillis())
            .username("newUserName")
            .password("newPassword");
    }

}
```

### 2.4 自定义 java 配置（可选）

```java
@Configuration(proxyBeanMethods = false)
public class MqttClientCustomizerConfiguration {

	@Bean
	public MqttClientCustomizer mqttClientCustomizer() {
		return new MqttClientCustomizer() {
			@Override
			public void customize(MqttClientCreator creator) {
				// 此处可自定义配置 creator，会覆盖 yml 中的配置
				System.out.println("----------------MqttServerCustomizer-----------------");
			}
		};
	}

}
```

### 2.5 订阅示例

```java
@Service
public class MqttClientSubscribeListener {
	private static final Logger logger = LoggerFactory.getLogger(MqttClientSubscribeListener.class);

	@MqttClientSubscribe("/test/#")
	public void subQos0(String topic, byte[] payload) {
		logger.info("topic:{} payload:{}", topic, new String(payload, StandardCharsets.UTF_8));
	}

	@MqttClientSubscribe(value = "/qos1/#", qos = MqttQoS.QOS1)
	public void subQos1(String topic, byte[] payload) {
		logger.info("topic:{} payload:{}", topic, new String(payload, StandardCharsets.UTF_8));
	}

	@MqttClientSubscribe("/sys/${productKey}/${deviceName}/thing/sub/register")
	public void thingSubRegister(String topic, byte[] payload) {
		// 1.3.8 开始支持，@MqttClientSubscribe 注解支持 ${} 变量替换，会默认替换成 +
		// 注意：mica-mqtt 会先从 Spring boot 配置中替换参数 ${}，如果存在配置会优先被替换。
		logger.info("topic:{} payload:{}", topic, new String(payload, StandardCharsets.UTF_8));
	}

	@MqttClientSubscribe(
		value = "/test/json",
		deserialize = MqttJsonDeserializer.class // 2.4.5 开始支持 自定义序列化，默认 json 序列化
	)
	public void testJson(String topic, MqttPublishMessage message, TestJsonBean data) {
		// 2.4.5 开始支持，支持 2 到 3 个参数，字段类型映射规则如下
		// String 字符串会默认映射到 topic，
		// MqttPublishMessage 会默认映射到 原始的消息，可以拿到 mqtt5 的 props 参数
		// byte[] 会映射到 mqtt 消息内容 payload
		// ByteBuffer 会映射到 mqtt 消息内容 payload
		// 其他类型会走序列化，确保消息能够序列化，默认为 json 序列化
		logger.info("topic:{} json data:{}", topic, data);
	}

}
```

### 2.6 共享订阅 topic 说明

mica-mqtt 支持两种**共享订阅**方式：

1. 共享订阅：订阅前缀 `$queue/`，多个客户端订阅了 `$queue/topic`，发布者发布到 `topic`，则只有一个客户端会接收到消息。
2. 分组订阅：订阅前缀 `$share/<group>/`，组客户端订阅了 `$share/group1/topic`、`$share/group2/topic`..，发布者发布到 `topic`，则消息会发布到每个 **group** 中，但是每个 **group** 中只有一个客户端会接收到消息。

**注意：** 如果发布的 `topic` 以 `/` 开头，例如：`/topic/test`，需要订阅 `$share/group1//topic/test`，另外 mica-mqtt 默认随机消息路由，共享订阅的多个客户端会随机收到消息。

### 2.7 MqttClientTemplate 使用示例

```java

import org.dromara.mica.mqtt.spring.client.MqttClientTemplate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;

/**
 * @author wsq
 */
@Service
public class MainService {
    private static final Logger logger = LoggerFactory.getLogger(MainService.class);
    @Autowired
    private MqttClientTemplate client;

    public boolean publish() {
        client.publish("/test/client", "mica最牛皮".getBytes(StandardCharsets.UTF_8));
        return true;
    }

    public boolean sub() {
        client.subQos0("/test/#", (context, topic, message, payload) -> {
            logger.info(topic + '\t' + new String(payload, StandardCharsets.UTF_8));
        });
        return true;
    }

}
```

## 3. 多个 mqtt client 客户端

### 3.1 自定义 MqttClientTemplate bean 2.2.11 开始已简化，老版本建议先升级。

```java
@Configuration
public class OtherMqttClientConfiguration {

	@Bean("mqttClientTemplate1")
	public MqttClientTemplate mqttClientTemplate1() {
		MqttClientCreator mqttClientCreator1 = MqttClient.create()
			.ip("mqtt.dreamlu.net")
			.username("mica")
			.password("mica");
		return new MqttClientTemplate(mqttClientCreator1);
	}

}
```

### 3.2 修改 starter 自带的 MqttClientTemplate Bean 引入

由于现在加入了一个新的名为 `mqttClientTemplate1` MqttClientTemplate，老的 starter 内置的 MqttClientTemplate 引入也需要添加 bean name。

```java
@Autowired
@Qualifier(MqttClientTemplate.DEFAULT_CLIENT_TEMPLATE_BEAN)
private MqttClientTemplate mqttClientTemplate;
```

### 3.3 新加入的 mqttClientTemplate1 MqttClientTemplate bean 引入

```java
@Autowired
@Qualifier("mqttClientTemplate1")
private MqttClientTemplate mqttClientTemplate;
```

### 3.4 新加入的 mqttClientTemplate1 注解订阅

注意：由于 `@MqttClientSubscribe` clientTemplateBean 默认是 `MqttClientTemplate.DEFAULT_CLIENT_TEMPLATE_BEAN`，所以新增的 `mqttClientTemplate1` 注解订阅的时候也需要配置。

```java
@MqttClientSubscribe(
    value = "/#", 
    clientTemplateBean = "mqttClientTemplate1"
)
public void sub1(String topic, byte[] payload) {
    logger.info("topic:{} payload:{}", topic, ByteBufferUtil.toString(payload));
}
```

---

---
url: /guide/spring/server.md
---
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 版本兼容

| 要求  | Spring boot 版本 |
|-----|----------------|
| 最高  | 4.x            |
| 最低  | 2.1.0.RELEASE  |

## 一、添加依赖

```xml
<dependency>
    <groupId>org.dromara.mica-mqtt</groupId>
    <artifactId>mica-mqtt-server-spring-boot-starter</artifactId>
    <version>${最新版本}</version>
</dependency>
```

## 二、mqtt 服务

### 2.1 配置项（2.5.x或以上）

```yaml
# mqtt 服务端配置
mqtt:
  server:
    enabled: true               # 是否开启服务端，默认：true
    name: Mica-Mqtt-Server      # 名称，默认：Mica-Mqtt-Server
    heartbeat-timeout: 120000   # 心跳超时，单位毫秒，默认: 1000 * 120
    read-buffer-size: 8KB       # 接收数据的 buffer size，默认：8k
    max-bytes-in-message: 10MB  # 消息解析最大 bytes 长度，默认：10M
    auth:
      enable: false             # 是否开启 mqtt 认证
      username: mica            # mqtt 认证用户名
      password: mica            # mqtt 认证密码
    debug: true                 # 如果开启 prometheus 指标收集建议关闭
    stat-enable: true           # 开启指标收集，debug 和 prometheus 开启时需要打开，默认开启，关闭节省内存
    mqtt-listener:              # mqtt 监听器
      enable: true              # 是否开启，默认：false
#      ip: "0.0.0.0"            # 服务端 ip 默认为空，0.0.0.0，建议不要设置
      port: 1883                # 端口，默认：1883
    mqtt-ssl-listener:          # mqtt ssl 监听器
      enable: false             # 是否开启，默认：false
      port: 8883                # 端口，默认：8883
      ssl:                      # ssl 配置，必须
        keystore-path:          # 必须参数：ssl keystore 目录，支持 classpath:/ 路径。
        keystore-pass:          # 必选参数：ssl keystore 密码
        truststore-path:        # 可选参数：ssl 双向认证 truststore 目录，支持 classpath:/ 路径。
        truststore-pass:        # 可选参数：ssl 双向认证 truststore 密码
        client-auth: none       # 是否需要客户端认证（双向认证），默认：NONE（不需要）
    ws-listener:                # websocket mqtt 监听器
      enable: true              # 是否开启，默认：false
      port: 8083                # websocket 端口，默认：8083
    wss-listener:               # websocket ssl mqtt 监听器
      enable: false             # 是否开启，默认：false
      port: 8084                # 端口，默认：8084
      ssl:                      # ssl 配置，必须
        keystore-path:          # 必须参数：ssl keystore 目录，支持 classpath:/ 路径。
        keystore-pass:          # 必选参数：ssl keystore 密码
        truststore-path:        # 可选参数：ssl 双向认证 truststore 目录，支持 classpath:/ 路径。
        truststore-pass:        # 可选参数：ssl 双向认证 truststore 密码
        client-auth: none       # 是否需要客户端认证（双向认证），默认：NONE（不需要）
    http-listener:
      enable: true
      port: 18083
      basic-auth:               # 基础认证
        enable: true
        username: mica
        password: mica
      mcp-server:               # 大模型 mcp
        enable: true
```

### 2.1 配置项（2.4.x或以下）

```yaml
mqtt:
  server:
    enabled: true               # 是否开启服务端，默认：true
#    ip: 0.0.0.0                # 服务端 ip 默认为空，0.0.0.0，建议不要设置
    port: 1883                  # 端口，默认：1883
    name: Mica-Mqtt-Server      # 名称，默认：Mica-Mqtt-Server
    heartbeat-timeout: 120000   # 心跳超时，单位毫秒，默认: 1000 * 120
    read-buffer-size: 8KB       # 接收数据的 buffer size，默认：8k
    max-bytes-in-message: 10MB  # 消息解析最大 bytes 长度，默认：10M
    auth:
      enable: false             # 是否开启 mqtt 认证
      username: mica            # mqtt 认证用户名
      password: mica            # mqtt 认证密码
    debug: true                 # 如果开启 prometheus 指标收集建议关闭
    stat-enable: true           # 开启指标收集，debug 和 prometheus 开启时需要打开，默认开启，关闭节省内存
    proxy-protocol-enable: false   # 代理协议支持，nginx 可开启 tcp proxy_protocol on; 时转发源 ip 信息。2.4.1 版本开始支持
    web-port: 8083              # http、websocket 端口，默认：8083
    websocket-enable: true      # 是否开启 websocket，默认： true
    http-enable: false          # 是否开启 http api，默认： false
    http-basic-auth:
      enable: false             # 是否开启 http basic auth，默认： false
      username: mica            # http basic auth 用户名
      password: mica            # http basic auth 密码
    ssl:                        # mqtt tcp ssl 认证
      enabled: false            # 是否开启 ssl 认证，2.1.0 开始支持双向认证
      keystore-path:            # 必须参数：ssl keystore 目录，支持 classpath:/ 路径。
      keystore-pass:            # 必选参数：ssl keystore 密码
      truststore-path:          # 可选参数：ssl 双向认证 truststore 目录，支持 classpath:/ 路径。
      truststore-pass:          # 可选参数：ssl 双向认证 truststore 密码
      client-auth: none         # 是否需要客户端认证（双向认证），默认：NONE（不需要）
```

注意：**ssl** 存在三种情况

| 服务端开启ssl                            | 客户端                                        |
| ---------------------------------------- | --------------------------------------------- |
| ClientAuth 为 NONE（不需要客户端验证）   | 仅仅需要开启 ssl 即可不用配置证书             |
| ClientAuth 为 OPTIONAL（与客户端协商）   | 需开启 ssl 并且配置 truststore 证书           |
| ClientAuth 为 REQUIRE (必须的客户端验证) | 需开启 ssl 并且配置 truststore、 keystore证书 |

### 2.2 可实现接口（注册成 Spring Bean 即可）

| 接口                            | 是否必须       | 说明                                            |
|-------------------------------|------------|-----------------------------------------------|
| IMqttServerUniqueIdService    | 否          | 用于 clientId 不唯一时，自定义实现唯一标识，后续接口使用它替代 clientId |
| IMqttServerAuthHandler        | 是          | 用于服务端认证                                       |
| IMqttServerSubscribeValidator | 否（建议实现）    | 1.1.3 新增，用于对客户端订阅校验                           |
| IMqttServerPublishPermission  | 否（建议实现）    | 1.2.2 新增，用于对客户端发布权限校验                         |
| IMqttMessageListener          | 否（1.3.x为否） | 消息监听                                          |
| IMqttConnectStatusListener    | 是          | 连接状态监听                                        |
| IMqttSessionManager           | 否          | session 管理                                    |
| IMqttSessionListener          | 否          | session 监听                                    |
| IMqttMessageStore             | 集群是，单机否    | 遗嘱和保留消息存储                                     |
| AbstractMqttMessageDispatcher | 集群是，单机否    | 消息转发，（遗嘱、保留消息转发）                              |
| IMqttMessageInterceptor       | 否          | 消息拦截器，1.3.9 新增                                |

### 2.3 `MqttServerFunction` 注解监听客户端上传的消息使用示例（v2.5.3开始支持）

```java
/**
 *  注解消息监听，注意：如果自行实现了 IMqttMessageListener，MqttServerFunction 注解就不生效了。
 */
@Slf4j
@Service
public class MqttServerMessageListener {

	/**
	 * MQTT消息处理函数
	 *
	 * @param topic mqtt Topic
	 * @param user  订阅消息的负载内容，默认 json 序列化
	 */
	@MqttServerFunction("/test/object")
	public void func1(String topic, User<?> user) {
		log.info("topic:{} user:{}", topic, user);
	}

	@MqttServerFunction("/test/client")
	public void func2(String topic, byte[] message) {
		log.info("topic:{} message:{}", topic, new String(message));
	}

	/**
	 * MQTT消息处理函数，匹配 mqtt Topic /test/+，如何需要匹配所以消息，请使用通配符 #
	 *
	 * @param context        ChannelContext，可选参数
	 * @param topic          实际接收到消息的主题名称，可选参数
	 * @param publishMessage 完整的MQTT发布消息对象，包含消息头和负载，可选参数
	 * @param message        消息负载内容，以字节数组形式提供，可选参数，也可支持对象形式，默认 json 序列化
	 */
	@MqttServerFunction("/test/${xxxx}")
	public void func3(ChannelContext context, String topic, MqttPublishMessage publishMessage, byte[] message) {
		// 获取客户端节点信息
		Node clientNode = context.getClientNode();
		// 记录接收到的MQTT消息信息
		log.info("clientNode:{} topic:{} publishMessage:{} message:{}", clientNode, topic, publishMessage, new String(message));
	}

}
```

### 2.3 传统 IMqttMessageListener (用于监听客户端上传的消息) 使用示例

```java
@Service
public class MqttServerMessageListener implements IMqttMessageListener {
    private static final Logger logger = LoggerFactory.getLogger(MqttServerMessageListener.class);

    @Override
    public void onMessage(ChannelContext context, String clientId, String topic, MqttQoS qoS, MqttPublishMessage message) {
        log.info("clientId:{} message:{} payload:{}", clientId, message, new String(message.getPayload(), StandardCharsets.UTF_8));
    }
}
```

### 2.4 自定义配置（可选）

```java
@Configuration(proxyBeanMethods = false)
public class MqttServerCustomizerConfiguration {

	@Bean
	public MqttServerCustomizer mqttServerCustomizer() {
		return new MqttServerCustomizer() {
			@Override
			public void customize(MqttServerCreator creator) {
				// 此处可自定义配置 creator，会覆盖 yml 中的配置
				System.out.println("----------------MqttServerCustomizer-----------------");
			}
		};
	}

}
```

### 2.5 MqttServerTemplate 使用示例

```java

import org.dromara.mica.mqtt.spring.server.MqttServerTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * @author wsq
 */
@Service
public class ServerService {
    @Autowired
    private MqttServerTemplate server;

    public boolean publish(String body) {
        server.publishAll("/test/123", body.getBytes(StandardCharsets.UTF_8));
        return true;
    }
}
```

### 2.6 客户端上下线监听

使用 Spring event 解耦客户端上下线监听，注意： `1.3.4` 开始支持。会跟自定义的 `IMqttConnectStatusListener` 实现冲突，取一即可。

```java
@Service
public class MqttConnectStatusListener {
	private static final Logger logger = LoggerFactory.getLogger(MqttConnectStatusListener.class);

	@EventListener
	public void online(MqttClientOnlineEvent event) {
		logger.info("MqttClientOnlineEvent:{}", event);
	}

	@EventListener
	public void offline(MqttClientOfflineEvent event) {
		logger.info("MqttClientOfflineEvent:{}", event);
	}

}
```

### 2.7 基于 mq 消息广播集群处理

详见: [mica-mqtt-broker](../../mica-mqtt-broker)

### 2.8 Prometheus + Grafana 监控对接

```xml
<!-- 开启 prometheus 指标收集 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

| 支持得指标                     | 说明             |
| ------------------------------ | ---------------- |
| mqtt\_connections\_accepted      | 共接受过连接数   |
| mqtt\_connections\_closed        | 关闭过的连接数   |
| mqtt\_connections\_size          | 当前连接数       |
| mqtt\_messages\_handled\_packets  | 已处理消息数     |
| mqtt\_messages\_handled\_bytes    | 已处理消息字节数  |
| mqtt\_messages\_received\_packets | 已接收消息数      |
| mqtt\_messages\_received\_bytes   | 已处理消息字节数 |
| mqtt\_messages\_send\_packets     | 已发送消息数      |
| mqtt\_messages\_send\_bytes       | 已发送消息字节数  |

---

---
url: /mqtt/clientId.md
---
# mqtt clientId
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## 多个客户端使用相同 clientId 会导致前者被踢下线（周期性互踢，频繁上下线）

* clientId 对于在 mqtt 中起着十分重要的作用，请不要随意设置，建议按照产品、设备、sn等维度生成，并且**确保唯一**。
* 如果实在是要兼容老业务，mica-mqtt 中可以实现 `IMqttServerUniqueIdService` 接口（1.1.4开始支持），返回的 `uniqueId` 会替代 clientId，后续的场景也是需要使用这个 `uniqueId` 来处理。

---

---
url: /mqtt/keepalive.md
---
# mqtt 心跳保活
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## mqtt 心跳超时

* 客户端默认心跳超时 60s
* 服务端默认心跳检测 120s
* 服务端会默认以 1.5 倍（`keepaliveBackoff` \* 2） **客户端心跳超时**进行判断，最长周期最长 2.5 倍。（所以客户端实际超时时间为 90s ~ 150s）

**拔网线**等**非正常断开**需要一个心跳检测周期才会触发断开。

---

---
url: /mqtt/qos.md
---
# mqtt 消息质量 QoS
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## mqtt 消息质量 QoS

在MQTT协议中，选择合适的QoS（服务质量）等级取决于数据上报的具体场景和需求。以下是针对不同QoS等级的分析和建议：

***

### **1. QoS 0（最多一次）**

* **特点**：消息发送后不保留、不确认，可能丢失。
* **适用场景**：
  * **高频低重要性数据**：如周期性传感器数据（温度、湿度等），允许偶发丢失。
  * **网络稳定且资源受限**：设备电量低或带宽有限时（如电池供电的IoT设备）。
  * **实时性要求高**：如实时监控仪表盘，短暂数据丢失不影响整体趋势。
* **不适用场景**：关键报警、计费数据或必须保证到达的场景。

***

### **2. QoS 1（至少一次）**

* **特点**：确保消息到达，但可能有重复。
* **适用场景**：
  * **关键但允许重复的数据**：如设备状态变更（开关机）、报警信息。
  * **网络不稳定但需可靠性**：需容忍重复但必须保证数据到达（需服务端去重）。
  * **中等资源设备**：设备和服务端能处理消息存储和重传。
* **注意事项**：需实现消息去重（如ID去重），避免重复数据干扰业务逻辑。

***

### **3. QoS 2（恰好一次）**

* **特点**：严格保证消息到达且不重复，但开销最大。
* **适用场景**：
  * **关键且不允许重复的数据**：如计费系统、金融交易指令。
  * **高可靠性要求**：如医疗设备的关键指令或工业控制信号。
* **不适用场景**：普通数据上报（资源消耗过高，性价比低）。

***

### **选择建议**

1. **优先 QoS 0 的场景**
   * 高频、海量、允许丢失的数据（如环境传感器每分钟上报一次）。
   * 资源严格受限的终端设备（如NB-IoT、LoRa等低功耗设备）。

2. **推荐 QoS 1 的场景**
   * 在大多数物联网数据上报场景中，QoS 1提供了可靠性（不丢失）与资源消耗的平衡，尤其适合重要但不极端敏感的数据（如设备状态、异常报警）。
   * 需在服务端实现简单的去重逻辑（例如通过消息ID或时间戳）。

3. **谨慎使用 QoS 2**
   * 仅在数据绝对不允许丢失且重复会引发严重问题时使用（如远程设备固件升级指令）。
   * 注意QoS 2会显著增加通信延迟和设备资源消耗。

***

### **其他考虑因素**

* **网络质量**：不稳定网络下优先QoS 1，稳定网络可尝试QoS 0。
* **设备资源**：低功耗设备避免QoS 2，甚至优先QoS 0。
* **业务逻辑容忍度**：能否接受丢失？能否处理重复？根据业务需求反向选择。

***

### **总结**

* **QoS 0**：适用于高频、低重要性、资源受限场景。
* **QoS 1**：平衡选择，适合大多数关键数据上报。
* **QoS 2**：仅用于极端严格场景，需谨慎评估必要性。

### **性能指标（mica-mqtt-client）**

* **QoS 0**：单客户端发送不建议超过 10000 条/秒，避免消息堆积，造成内存溢出。
* **QoS 1**：单客户端发送不建议超过 5000 条/秒，避免重试堆积，造成内存溢出。
* **QoS 2**：单客户端发送不建议超过 3000 条/秒，避免重试堆积，造成内存溢出。

根据实际场景测试不同QoS的稳定性和资源消耗，最终选择性价比最高的方案。

---

---
url: /mqtt/retain.md
---
# mqtt 保留消息
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## MQTT 保留消息场景

* 例如，某设备定期发布自身 GPS 坐标，但对于订阅者而言，从它发起订阅到第一次收到数据可能需要几秒钟，也可能需要十几分钟甚至更多，这样并不友好。因此 MQTT 引入了保留消息。
* 而每当有订阅者建立订阅时，服务端就会查找是否存在匹配该订阅的保留消息，如果保留消息存在，就会立即转发给订阅者。
* 借助保留消息，新的订阅者能够立即获取最近的状态。

---

---
url: /mqtt/tool.md
---
# mqtt 客户端工具
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## mqtt 桌面工具

* mqttx 优雅的跨平台 MQTT 5.0 客户端工具：https://mqttx.app/cn/
* mqttx.fx mqtt 客户端：http://mqttfx.org/

## mqtt-client 库

* android: https://github.com/eclipse/paho.mqtt.android
* ios: https://github.com/novastone-media/MQTT-Client-Framework
* js(uniapp、小程序): https://github.com/mqttjs/MQTT.js
* dart mqtt client: https://pub.dev/packages/mqtt\_client

---

---
url: /mqtt/topic.md
---
# mqtt Topic 规则
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## topic 通配符（订阅才可以使用通配符，发布不允许出现通配符）

* `/`：用来表示层次，比如 `a/b`，`a/b/c`。
* `#`：表示匹配 `>=0` 个层次，比如 `a/#` 就匹配 `a/`，`a/b`，`a/b/c`。单独的一个 `#` 表示匹配所有。不允许 `a#` 和 `a/#/c`。
* `+`：表示匹配一个层次，例如 `a/+` 匹配 `a/b`，`a/c`，不匹配 `a/b/c`。单独的一个 `+` 是允许的，`a+` 不允许，也可以和多层通配符一起使用，`+/tennis/# `、`sport/+/player1` 都有有效的。

## 共享订阅

**mica-mqtt** 支持两种**共享订阅**方式：

1. 共享订阅：订阅前缀 `$queue/`，多个客户端订阅了 `$queue/topic`，发布者发布到 `topic`，则只有一个客户端会接收到消息。
2. 分组订阅：订阅前缀 `$share/<group>/`，组客户端订阅了 `$share/group1/topic`、`$share/group2/topic`..，发布者发布到 `topic`，则消息会发布到每个 **group** 中，但是每个 **group** 中只有一个客户端会接收到消息。

**注意：** 如果发布的 `topic` 以 `/` 开头，例如：`/topic/test`，需要订阅 `$share/group1//topic/test`，另外 mica-mqtt 默认随机消息路由，共享订阅的多个客户端会随机收到消息。

---

---
url: /mqtt/will.md
---
# mqtt 遗嘱消息
## 科普视频

* [mqtt科普、mqttx、mica-mqtt的使用**视频**](https://www.bilibili.com/video/BV1wv4y1F7Av/)

## MQTT 遗嘱消息场景

* 当客户端断开连接时，发送给相关的订阅者的遗嘱消息。在设备 A 进行连接时候，遗嘱消息设定为 `offline`，手机App B 订阅这个遗嘱主题。
* 当 A 异常断开时，手机App B 会收到这个 `offline` 的遗嘱消息，从而知道设备 A 离线了。

---

---
url: /version/changelog.md
---
# mica-mqtt 发行版本
### v2.5.7 - 2025-11-07

* :sparkles: mica-mqtt-server 新增 `/api/v1/stats/sse` 接口，支持通过 SSE 实时获取服务器统计信息
* :sparkles: example 升级到 solon 3.7.0 更改相关依赖命名规则
* :arrow\_up: 升级 mica-net 到 1.2.2 支持 snack4 json 序列化，内存优化和消息发送性能优化
* :bug: mica-mqtt-server-solon-plugin 移除 MqttServerConfiguration bean MqttFunctionManager 的 static 修饰符

### v2.5.6 - 2025-10-27

* :bug: 修复 MQTT 解码器中的缓冲区读取问题，修复解码异常重连后无法恢复的问题。（所有版本）
* :arrow\_up: 升级 mica-net 到 1.2.1，修改慢包读取 (gitee #ID3IAU)，影响范围（2.5.5）

### v2.5.5 - 2025-10-10

* :sparkles: mqtt-client 添加通过 `Consumer<MqttWillPublishProperties>` 函数式接口自定义遗嘱属性
* :sparkles: mqtt-client 添加直接使用 MqttPublishBuilder 发布消息
* :sparkles: mqtt-client 添加 disconnectBeforeStop 配置（默认 true），断开连接前是否发送 disconnect 消息，感谢 `@steven` 反馈（gitee #ICXY4A）
* :sparkles: mica-mqtt-server 使用 ConcurrentHashMap 替代 IntObjectHashMap，优化内存会话管理
* :sparkles: mica-mqtt-server-spring-boot-starter bean 加载顺序优化，避免出现提示
* :arrow\_up: 升级 mica-net 到 1.2.0，调整慢包攻击规则和支持 jackson3，感谢 `@well` 反馈（gitee #ICXF5N）

### v2.5.4 - 2025-08-29

* :sparkles: mica-mqtt-server 使用前缀树管理 MQTT 订阅。
* :sparkles: mica-mqtt-server 心跳超时小于等于0时，不开启心跳检测。（不建议这样使用）感谢 `@刘业兴` 反馈（gitee #ICTT2V）
* :sparkles: mica-mqtt-server solon 和 spring 插件，将 `@MqttServerFunction` 统一到 mica-mqtt-common 包中，不兼容。
* :sparkles: mica-mqtt-server solon 和 spring 插件，`@MqttServerFunction` 增加 topic 变量解析功能，支持解析 Map\<String, String> 类型的 topic 中的 ${topicVars} 变量参数。
* :sparkles: mica-mqtt-client solon 和 spring 插件，将 `@MqttClientSubscribe` 统一到 mica-mqtt-common 包中，MqttClientTemplate 中的 `DEFAULT_CLIENT_TEMPLATE_BEAN` 常量定义移动到了 `@MqttClientSubscribe`，不兼容。
* :sparkles: mica-mqtt-client solon 和 spring 插件，`@MqttClientSubscribe` 注解订阅，增加 topic 变量解析功能，支持解析 Map\<String, String> 类型的 topic 中的 ${topicVars} 变量参数。
* :sparkles: mica-mqtt-codec 移除了 MqttCodecUtil 中的 `isValidPublishTopicName` 方法 ，直接使用 `isTopicFilter` 校验发布主题名称是否包含通配符。
* :sparkles: mica-mqtt-codec 包调整，重命名类名、方法名，重构 MQTT 消息构建器类（为后续方便做准备），不兼容。
* :sparkles: mica-mqtt-common `TopicUtil` 调整 validateTopicFilter 方法，移除了对空白字符的校验。（注意：emqx 支持使用空白字符，mosquitto 不支持）。
* :sparkles: `TopicUtil` 和 `MqttCodecUtil` 增加对 topic 中空白符的日志提示。感谢 `@长草颜团子` 反馈（gitee #26）

### v2.5.3 - 2025-08-03

* :sparkles: mica-mqtt-server-spring-boot-starter 支持注解 `@MqttServerFunction` 监听
* :sparkles: mica-mqtt-server-solon-plugin 支持注解 `@MqttServerFunction` 监听
* :sparkles: mica-mqtt-client-solon-plugin 更新 `solon-configuration-metadata.json`
* :sparkles: mica-mqtt-codec `ReasonCode` 统一移动到 `codes` 包（不影响老用户升级）

### v2.5.2 - 2025-07-27

* :bug: mica-mqtt-server 修复启动报错，感谢 `CoderKK` 反馈（gitee #ICOQ3Q）

### v2.5.1 - 2025-07-24

* :sparkles: mica-mqtt-server 优化 sse mcp，添加 sse 心跳
* :sparkles: mica-mqtt-client 内置 ssl SNI 支持，感谢 `sword007`、`@TomatoLay` 反馈（gitee #ICKBAY #ICEANP）
* :sparkles: mica-mqtt-client 支持多网卡下指定网卡 `bindIp`（网卡对应IP）和 `bindNetworkInterface`（网卡名） 配置（2个方法使用任意一个即可）。感谢 `@iovera` 反馈（gitee #ICO699)
* :bug: mica-mqtt-client 高CPU下 packetId 生成超限，感谢 `@火焰之魂` 反馈（gitee #ICLXC3）

### v2.5.0 - 2025-07-12

* :sparkles: mica-mqtt X AI，mica-mqtt-server 支持大模型 mcp
* :sparkles: mica-mqtt-server 支持同时配置多协议支持，拆分 `http(默认端口18083)` 和 `websocket(默认端口8083)`，使统计更加准确
* :sparkles: mica-mqtt-server spring、solon 插件删除不推荐使用的 `EventMqttMessageListener`
* :sparkles: mica-mqtt-server 调整保留消息的规则，支持 `$retain` 带存储周期的保留消息 感谢 `@tan90` pr #ICB9I2 #23
* :sparkles: mica-mqtt-client 删除 `IMqttClientMessageIdGenerator` 接口合入 `IMqttClientSession` 接口
* :sparkles: mica-mqtt-client 默认 mqtt5.0，cleanSession 改为 cleanStart 感谢 `@tan90` 反馈 (gitee #IBKKAG)
* :sparkles: mica-mqtt-client MqttClient 和 MqttClientTemplate 支持通过代理接口来进行Publish 感谢 `@galaxy-sea` pr (github #100)
* :sparkles: mica-mqtt-codec 完全同步成私服版，将 MqttProperties 内部类拆解出来，方便使用
* :sparkles: mica-mqtt client、server solon 插件添加对 [Solon IDEA](https://plugins.jetbrains.com/plugin/21380-solon) 插件配置提示支持。
* :sparkles: 移除 mica-mqtt-broker，未来重构
* :sparkles: 统一参数命名，userName 统一为 username。
* :sparkles: 优化部分日志，使用中文，方便大家排查问题

### v2.4.9 - 2025-06-27

* :bug: mqtt server 修复 http/ws 端口占用 gitee #ICID15

### v2.4.8 - 2025-06-20

* :sparkles: mica-mqtt-client-spring-boot-starter `MqttClientSubscribeDetector` bean 配置改成 `static` 方法。
* :sparkles: mica-mqtt-server 调整保留消息标志位的规则。

注意：2.4.x 不会再新增功能，只做 bug 修复，新功能将会在 2.5.x 中进行。减轻老版本用户的升级成本。

### v2.4.7 - 2025-06-02

* :sparkles: mica-mqtt-client、mica-mqtt-server publish相关接口支持object发送 (github #98) 感谢 `@galaxy-sea` 贡献
* :sparkles: mica-mqtt-client 调整 MqttClient#reconnect 策略，（gitee #IBY5LQ）感谢 `@拉风的CC` 反馈。
* :sparkles: mica-mqtt-codec MqttCodecUtil#isTopicFilter 代码优化改为逆序循环
* :sparkles: mica-mqtt-codec 代码优化详见： https://github.com/netty/netty/pull/15227
* :sparkles: mica-net-http http api 响应头 name 不转换成小写
* :wrench: mica-mqtt-common 更新 `module-info.java` 添加序列化模块
* :bug: mica-net-utils DefaultThreadFactory 不应该共用。

### v2.4.6 - 2025-05-19

* :sparkles: mica-mqtt-client-spring-boot-starter MqttDeserializer 接口重写，支持泛型调用 (github #95) 感谢 `@galaxy-sea` 贡献
* :sparkles: mica-mqtt-client 批量订阅兼容 mqtt 3.1.1 部分 broker 只返回一个 reasonCode 的情况。感谢 `@Jacky` 反馈
* :sparkles: mica-mqtt-server-solon-plugin 添加对 metrics 指标的支持
* :sparkles: mica-mqtt-client-solon-plugin 注解订阅支持自定义序列化（默认 json 序列化）和泛型

### v2.4.5 - 2025-05-06

* :sparkles: mica-mqtt-client-spring-boot-starter 的 `@MqttClientSubscribe` 注解支持自定义反序列化。
* :sparkles: 优化代码 Spring Boot Client 可以自定义 MqttClientSubscribeDetector github #90 感谢 `@galaxy-sea` 贡献
* :sparkles: 升级 mica-net 到 1.1.6，解决 eclipse paho mqtt websocket client 连接 mica-mqtt server 报错
* :sparkles: 依赖调整，减少 example 示例项目的安全提示
* :bug: 解决服务端重启时 client有消息发送，导致 client 无法正常重连 gitee #IC4DWT 感谢 `@wtjperi2003` 反馈
* :bug: 同步 netty mqtt codec Fix the assignment error of maxQoS parameter in ConnAck Properties

### v2.4.4 - 2025-04-13

* :sparkles: mica-mqtt-server，更好的兼容 Android 环境。github #81 感谢 `@KittenBall` 的联调测试。

### v2.4.3 - 2025-03-23

* :sparkles: Central Portal 开始支持 Snapshots（仅存储90天，需尽快切到最新的正式版），dev 分支提交后 Github action 自动发布快照版。
* :sparkles: 精简，删除没有用到的代码，下沉到 mica-net。
* :sparkles: mica-mqtt-client 添加 heartbeatMode 和 heartbeatTimeoutStrategy，用于某些弱网场景 gitee #IBSMZ7 感谢 `@拉风的CC` 反馈。
* :sparkles: mica-mqtt-server 默认依赖上 mica-net-http，不再需要手动添加依赖，简化使用。
* :sparkles: mica-mqtt-server-spring-boot-starter MqttServerTemplate 暴露 `getMqttServer()` 方法，方便使用。
* :sparkles: mica-mqtt-server-spring-boot-starter 兼容存在 `MeterRegistry` 类，但是 `MeterRegistry` bean 不存在的情况。gitee #IBLBCY 感谢 `@xxg` 反馈。

### v2.4.2 - 2025-01-24

* :sparkles: mica-mqtt-client Spring Boot stater 和 solon 插件添加工作线程数配置 `bizThreadPoolSize` (默认：2，如果消息量大，业务复杂处理慢，例如做emqx消息转发处理，可调大此配置)。
* :sparkles: mica-mqtt-client Spring Boot stater 和 solon 插件添加 MQTT5.0 的 `sessionExpiryIntervalSecs` 配置 gitee #IBIE27 感谢 `@cyber` 反馈。
* :sparkles: mica-mqtt-client 调整重连重新订阅逻辑，Spring Boot stater 和 solon 插件 `@MqttClientSubscribe` 注解订阅，保留 session 重连时不丢失消息 gitee #IBIE27 感谢 `@cyber` 反馈。
* :sparkles: mica-mqtt-client DefaultMqttClientSession 移除 `final` 修饰，方便继承自定义。
* :sparkles: mica-mqtt-client 将 clientId 绑定到 context 上，可以使用 `context.getId()` 获取，方便多 mqtt client 实例下使用，gitee #IBHHB1 感谢 `@cv` 反馈。
* :sparkles: mica-mqtt-server proxy 代理协议简化，已测底抽象到 mica-net。
* :sparkles: mica-mqtt-common 调整 `TopicUtil`，支持原生 Android，gitee #IBJBFL 感谢 `@DeanNode` 反馈。
* :sparkles: mica-mqtt-server 默认的 nodeName 改为随机 `nanoId`，支持原生 Android，gitee #IBJBFL 感谢 `@DeanNode` 反馈。
* :sparkles: 将 MqttServerCustomizer 和 MqttClientCustomizer 抽到 mica-mqtt-server、mica-mqtt-client 方便组件封装，需要调整包名，请先将老的包导入删除，idea 会自动引入新的包。
* :bug: mica-mqtt-client-spring-boot-starter 修复 Spring Boot 3.2 启动时出现警告 gitee #IBITP5 感谢 `@cyber` 反馈。

### v2.4.1 - 2025-01-04

* :sparkles: mqtt server 统一 topic 订阅、发布认证日志方便排查问题。
* :sparkles: mqtt server 添加 PROXY protocol v1 支持，nginx 可开启 tcp proxy\_protocol on; 时转发源 ip 信息。
* :memo: 修复文档 maven 坐标错误。
* :bug: 修复 spring boot 项目使用全局懒加载 topic无法订阅 gitee #IBFIV8 感谢 `@xixuanhao` 反馈

### v2.4.0 - 2024-12-07

* :sparkles: http api 添加 `stats`、`clients` 列表和 `client详情` 接口。
* :sparkles: MqttServer 和 MqttServerTemplate 添加 `getClientInfo` `getClients` 系列客户端信息接口。
* :sparkles: MqttServer 和 MqttServerTemplate 添加 `getSubscriptions` 获取客户端订阅列表接口。
* :sparkles: MqttServer 和 MqttServerTemplate 添加 `getStat` 统计接口。
* :truck: 调整 maven groupId `net.dreamlu` 到新的 `org.dromara.mica-mqtt`。
* :truck: 调整包名 `net.dreamlu.iot.mqtt` 到新的 `org.dromara.mica.mqtt`，其他均保持不变。
* :truck: 切换到 central sonatype，central sonatype 不支持快照版，mica-mqtt 不再发布快照版。
* :bug: 修复订阅发送时机问题 gitee #IB72L6 感谢 `@江上烽` 反馈

### v2.3.9 - 2024-11-16

* :sparkles: ssl 支持 **PKCS12** 证书，根据文件后缀自动判断 `.jks、.keystore` 识别为 **JKS证书**，`.p12、.pfx` 识别成 **PKCS12证书**。其他默认成**JKS**
* :sparkles: 优化 **Solon** 版本依赖（仅编译依赖），兼容 `2.8.0` 和 `2.8.0` 以上版本。

### v2.3.8 - 2024-09-26

* :sparkles: 升级到 solon v3, 调整 solon 版本兼容
* :bug: mica-net 心跳支持了 `keepAliveBackoff`，mica-mqtt 漏改规则（影响范围：mica-mqtt server 开源版，私服版无此问题。） gitee #IAW9FC 感谢 `tan90` 反馈。

### v2.3.7 - 2024-09-22

* :sparkles: 优化 Mqtt server starter 添加 schedule 系列方法。
* :sparkles: MqttClient schedule 系列方法下层到底层，方法改造。

### v2.3.6 - 2024-09-14

* :sparkles: mica-mqtt server 和 client 优化 stop，支持 stop 后重新配置再启动（注意：需要重新配置，因为老的线程池已经停止）。
* :sparkles: mica-mqtt server 和 client Spring boot starter 支持 Spring boot devtools 热启动。
* :sparkles: `FastJsonMessageSerializer` 重构为 `JsonMessageSerializer`。
* :sparkles: 添加 `module-info.java` 方便模块化。

### v2.3.5 - 2024-09-01

* :sparkles: 新增 `SSLEngineCustomizer`，用于自定义 tls 协议版本和加密套件。
* :sparkles: !20 修改了 solon 插件的默认配置数值，感谢 `@peigen` pr。

### v2.3.4 - 2024-08-10

* :sparkles: mica-mqtt 合入 `mica-mqtt-client-solon-plugin` 和 `mica-mqtt-server-solon-plugin` 感谢 `@peigenlpy`
* :sparkles: jfinal 插件重命名为 `mica-mqtt-client-jfinal-plugin` 和 `mica-mqtt-server-jfinal-plugin`
* :bug: mica-mqtt-server 修复分组订阅删除，感谢 `@tangjj` 反馈。

### v2.3.3 - 2024-07-22

* :sparkles: mica-mqtt-server 可停止，同步捐助版。
* :sparkles: mica-mqtt-server 添加 schedule 系列方法，同步捐助版。
* :sparkles: mica-mqtt 代码优化 TopicUtil 优化 getTopicFilter 方法。
* :sparkles: mica-mqtt 优化 AckTimerTask 和 retry 重发日志。gitee #IABQ7L 感谢 `@tan90` 反馈。
* :sparkles: mica-mqtt-client-spring-boot-starter 更加方便自定义 MqttClientTemplate。
* :sparkles: mica-mqtt-client-spring-boot-starter MqttClientTemplate 暴露更多方法，方便使用。
* :sparkles: mica-mqtt-example 添加 ssl 测试代码
* :bug: mica-mqtt-client 修复 ssl 服务端重启问题 gitee #IA9FFW #IAEHOD 感谢 `@geekerstar` `@hangrj` 反馈。

### v2.3.1 - 2024-06-25

* :sparkles: mica-mqtt-server 重构心跳，心跳检测模式默认为：最后接收的数据时间。gitee #I9R0SN #IA69SM 感谢 `@HY` `@tan90` 反馈。
* :sparkles: mica-mqtt-server 优化端口占用的异常提示，方便排查。
* :sparkles: mica-mqtt client 使用 mica-net 内置的心跳检测，内置心跳已重构。
* :sparkles: mica-mqtt-client 重连不管服务端是否存在 session 都发送订阅。gitee #I9VIUV 感谢 `@xiaochonzi` 反馈。
* :sparkles: 快照版也打 source jar 方便使用。
* :sparkles: 添加 renovate bot 方便更新依赖和插件版本。
* :sparkles: 优化 issue.yml 和 github action。

### v2.3.0 - 2024-05-26

* :sparkles: mica-mqtt 优化 MqttQoS 枚举，改为 `MqttQoS.QOS0`，方便使用（不兼容）。
* :sparkles: mica-mqtt-client 同步私服部分功能，支持 stop 完全停止。
* :sparkles: mica-mqtt-client 同步私服部分功能，MqttClient 都添加了 `schedule`、`scheduleOnce` 方法，（**耗时任务，请务必自定义线程池**）
* :sparkles: mica-mqtt-server 优化设备离线，简化代码。
* :sparkles: mica-mqtt-server 用户绑定使用 tio 内置 `Tio.bindUser(context, username)`。
* :bug: 修复 @MqttClientSubscribe 类型错误时的异常提示。
* :bug: mica-mqtt-client 修复重连可能失败的问题 gitee #I9RI8E 感谢 `@YYGuo` 反馈。

### v2.2.13 - 2024-05-12

* :sparkles: mica-mqtt-codec MqttVersion 添加版本全名。
* :sparkles: mica-mqtt-codec MqttConnectReasonCode 添加中文说明。
* :bug: mica-mqtt-server 保留消息下发时没有订阅也应该先存储 gitee #I9IYX1。

### v2.2.12 - 2024-04-16

* :bug: mica-mqtt-server 遗嘱消息发送判断

### v2.2.11 - 2024-04-13

* :sparkles: mica-mqtt-client-spring-boot-starter 简化 MqttClientTemplate 构造，方便自定义。
* :sparkles: mica-mqtt-client-spring-boot-starter 优化 spring event mqtt client 连接监听。
* :sparkles: mica-mqtt-client-spring-boot-starter 优化注解订阅。
* :bug: mqtt-client 修复 mqtt5 props 和遗嘱同时配置时连接编码问题。

### v2.2.10 - 2024-03-23

* :sparkles: mica-mqtt-client 优化 client publish 时还没有认证的情况。
* :sparkles: mica-mqtt-client-spring-boot-starter 优化注解订阅，支持 clean session false 重启接收消息。

### v2.2.9 - 2024-02-25

* :sparkles: mica-mqtt-server 拦截器 IMqttMessageInterceptor 添加 onAfterConnected 方法，方便在连接时做黑名单等功能。
* :sparkles: mica-mqtt-client 添加私服版客户端全局订阅功能和添加使用文档。
* :boom: mica-mqtt-common 删除弃用的 ThreadUtil。

### v2.2.8 - 2024-01-19

* :sparkles: jfinal-mica-mqtt-client 启动改为同步连接。
* :bug: mica-mqtt-client 修复 `isConnected` 判断。`2.2.7` 中存在此问题。
* :arrow\_up: 依赖升级

### v2.2.7 - 2024-01-03

* :sparkles: mica-mqtt-server mqttws开启了ssl后，使用mqtt.js去连接，多刷新几次就会超时 gitee #I8LCMY
* :sparkles: mica-mqtt-example 优化 graalvm 配置，感谢 github `@litongjava` 反馈

### v2.2.6 - 2023-11-26

* :sparkles: mica-mqtt-server 添加 `webConfigCustomize` 支持自定义 http 和 ws 配置，可用于 gitee #I8HF7P
* :sparkles: mica-mqtt-client 添加连接测试功能 connectTest gitee #I8J35M 感谢 `@彭蕾` 反馈
* :sparkles: mica-mqtt-example 更新 graalvm 配置

### v2.2.5.1 - 2023-11-01

* :poop: mica-mqtt-client mqttExecutor 方法参数类型漏改。

### v2.2.5 - 2023-10-05

* :sparkles: mqtt 业务线程池支持自定义设置为 java21虚拟线程。
* :sparkles: 更新 GitHub action，java17 改为 java21。
* :sparkles: ThreadUtil 弃用（暂时未删），切换到 mica-net 中的 ThreadUtils。

### v2.2.4 - 2023-09-02

* :sparkles: 合并去年开源之夏的服务端共享订阅和完善（捐助VIP版采用 topic 树存储，跟 topic 数无关，百万 topic 性能依旧）。
* :sparkles: 优化 topic 检验
* :bug: 相同 clientId 订阅相同 匹配 topic 应该取最大的qos gitee #I7WWPN

### v2.2.3 - 2023-07-23

* :sparkles: mqtt server http api publish 不按 clientId 进行路由（无实际意义），而是按 topic，规则改为同 emqx。
* :sparkles: mqtt server http api publish 触发 onMessage 消息监听。
* :arrow\_up: 依赖升级

### v2.2.2 - 2023-06-17

* :sparkles: mica-mqtt-client 心跳包日志受 debug 控制
* :sparkles: mica-mqtt-broker 的集群改为 redis stream 实现。
* :bug: 修复 starter ssl truststorePass 配置，github #6 感谢 `@zkname` 反馈

### v2.2.1 - 2023-05-28

* :zap: mica-mqtt-client 共享订阅更好的兼容 emqx 高版本，gitee #I786GU
* :arrow\_up: 依赖升级

### v2.2.0 - 2023-05-14

* :sparkles: MqttPublishMessage payload 参数均由 `ByteBuffer` 改为 `byte[]`，简化代码，方便使用。
* :bug: 修复 高并发场景下取消订阅时报 ConcurrentModificationException github #5 感谢 `@yinyuncan` 反馈

### v2.1.2 - 2023-04-26

* :sparkles: mica-mqtt-client 支持 `reconnect(String ip, int port)` 转移到其他服务，订阅保留，连接成功时自动重新订阅。感谢 `@powerxie` 反馈
* :sparkles: 优化 `TopicUtil#getTopicFilter()` topic 占位符替换。
* :sparkles: 调整 mica-mqtt-client-spring-boot-starter 启动时机。`MqttClientCustomizer` 支持从数据库中获取配置。感谢 `@powerxie` 反馈
* :memo: 修复迁移指南**ssl配置**文档错误
* :bug: 修复包长度计算错误，压测下协议解析异常 gitee #I6YOMD 感谢 `@powerxie` 反馈

### v2.1.1 - 2023-04-08

* :sparkles: mica-mqtt-server http-api 不再强制依赖 `fastjson` 还支持 `Jackson`、`Fastjson2`、`Gson`、`hutool-json` 和自定义, `@皮球` 反馈 gitee #I6O49D。
* :sparkles: mica-mqtt-codec 删除 `org.dromara.mica.mqtt.codec.ByteBufferUtil`，2.1.0 漏删。
* :sparkles: mica-mqtt-codec 兼容 qos大于0，messageId == 0，做 qos 降级处理，`@那一刹的容颜` 反馈，详见 gitee #I6PFIH
* :sparkles: mica-mqtt-codec maxClientIdLength 默认改为 64，gitee #I6P2CG
* :sparkles: mica-mqtt-client 优化链接时的遗嘱消息构建，默认为 qos0。`@tan90` 反馈 gitee #I6BRBV
* :bug: mqtt-server 修复 mqtt.js websocket 空包问题，感谢群友反馈。
* :bug: mqtt-server 修复 websocket mqtt 包长度判断问题。
* :arrow\_up: 依赖升级

### v2.1.0 - 2023-03-05

* :sparkles: 【不兼容】调整接口参数，方便使用
* :sparkles: 【不兼容】底层重构调整
* :sparkles: 兼容更多 Spring boot 版本，支持 `2.1.0.RELEASE` 以上版本。
* :sparkles: ssl 支持双向认证 gitee #I61AHJ 感谢 @DoubleH 反馈
* :bug: 修复遗嘱消息判断 gitee #I6BRBV 感谢 @tan90 反馈。
* :bug: 修复错别字 gitee #I6F2PA 感谢 @hpz 反馈
* :arrow\_up: 依赖升级

### v2.0.3 - 2022-09-18

* :sparkles: 完善 ssl 方法，方便使用。
* :arrow\_up: 依赖升级，避免依赖导致的 bug。

### v2.0.2 - 2022-09-13

* :bug: 彻底修复解码异常: `BufferUnderflowException`。

### v2.0.1 - 2022-09-12

* :sparkles: 优化 MqttWebServer 配置。
* :sparkles: mica-mqtt-example 添加华为云iot连接示例。
* :sparkles: mica-mqtt-example 改为使用 tinylog。
* :bug: 修复解码异常: `BufferUnderflowException`。

### v2.0.0 - 2022-09-04

* :sparkles: mica mqtt server 完善方法，方便使用。
* :sparkles: 切换到自维护的 java8 t-io，注意：升级了 t-io 部分类名变更。

### v1.3.9 - 2022-08-28

* :sparkles: mica-mqtt server 添加消息拦截器，gitee #I5KLST
* :sparkles: mica-mqtt client、server ack 优化和完善，可自定义 ackService。
* :sparkles: mica-mqtt client stater MqttClientTemplate 完善，统一调整客户端示例。
* :sparkles: mica-mqtt client 优化客户端心跳和心跳日志优化。
* :sparkles: mica-mqtt client 订阅代码优化。
* :sparkles: mica-mqtt codec 代码优化。
* :sparkles: test 代码优化，更加符合 junit5 规范。
* :bug: mqtt client Qos2 修复。

### v1.3.8 - 2022-08-11

* :sparkles: mica-mqtt codec 代码优化。
* :sparkles: mica-mqtt server 使用 Spring event 解耦消息监听。
* :sparkles: mica-mqtt client stater，@MqttClientSubscribe topic 支持其他变量 ${productKey} 自动替换成 +。
* :memo: 添加演示地址
* :bug: 修复 mica-mqtt client 心跳发送问题。gitee #I5LQXV 感谢 `@iTong` 反馈。

### v1.3.7 - 2022-07-24

* :sparkles: 添加 mica-mqtt jfinal client 和 server 插件。
* :sparkles: mica-mqtt server 代码优化，useQueueDecode 默认为 true。
* :sparkles: mica-mqtt client 监听回调代码优化。
* :memo: 添加赞助，让你我走的更远！！！
* :arrow\_up: 依赖升级。

### v1.3.6 - 2022-06-25

* :sparkles: mica-mqtt 统一调整最大的消息体和一次读取的字节数。
* :sparkles: mica-mqtt client 简化 ssl 开启。
* :sparkles: mica-mqtt server 添加默认的账号密码配置。
* :arrow\_up: 依赖升级

### v1.3.4 - 2022-06-06

* :sparkles: mica-mqtt starter 使用 Spring event 解耦 mqtt client 断连事件。
* :sparkles: mica-mqtt server `IMqttConnectStatusListener#offline` 方法添加 `reason` 断开原因字段。
* :sparkles: 添加赞助计划。**捐助共勉，让你我走的更远！！！**
* :bug: 修复 http api 响应问题。

### v1.3.3 - 2022-05-28

* :sparkles: mica-mqtt 优化线程池。
* :sparkles: mica-mqtt 添加 Compression 压缩接口。
* :sparkles: mica-mqtt 添加 kafka TimingWheel 重构 ack。
* :sparkles: mica-mqtt server 添加 `MqttClusterMessageListener` 方便集群消息处理。
* :sparkles: mica-mqtt client 优化客户端取消订阅逻辑，gitee #I5779A 感谢 `@杨钊` 同学反馈。
* :arrow\_up: 升级 fastjson 到 1.2.83。

### v1.3.2 - 2022-05-09

* :sparkles: mica-mqtt topic 匹配完善。
* :sparkles: mica-mqtt 订阅、发布时添加 topicFilter、topicName 校验。

### v1.3.1 - 2022-05-08

* :sparkles: mica-mqtt-broker 默认开启 http 和 basic auth。
* :sparkles: mica-mqtt server 添加服务端共享订阅接口，方便开源之夏学生参与。
* :sparkles: mica-mqtt server 添加 IMqttSessionListener。
* :sparkles: mica-mqtt server publish 保留消息存储。
* :sparkles: mica-mqtt server 统一 http 响应模型、优化 http 请求判断。
* :sparkles: mica-mqtt server 优化 MqttHttpRoutes，添加获取所有路由的方法。
* :sparkles: mica-mqtt server 完善 Result 和 http api。
* :sparkles: mica-mqtt server http api 添加 endpoints 列表接口。
* :sparkles: mica-mqtt client 添加同步连接 connectSync 方法。
* :sparkles: mica-mqtt client 优化 bean 依赖，减少循环依赖可能性。
* :bug: 重构 mqtt topic 匹配规则，提升性能减少内存占用，修复 gitee #I56BTC
* :arrow\_up: spring boot、mica 版本升级

### v1.3.0 - 2022-04-17

* :sparkles: mica-mqtt mqtt-server 简化，默认多设备可以直接互相订阅和处理消息。
* :sparkles: mica-mqtt server、client 添加 `tioConfigCustomize` 方法，方便更大程度的自定义 TioConfig。
* :sparkles: 拆分 mica-mqtt-client-spring-boot-starter 和 mica-mqtt-server-spring-boot-starter gitee #I4OTC5
* :sparkles: mica-mqtt-client-spring-boot-example 添加重连动态更新 clientId、username、password 示例。
* :sparkles: mica-mqtt server 添加根据踢出指定 clientId 的 http api 接口。
* :sparkles: mica-mqtt server IMqttConnectStatusListener api 调整，添加用户名字段。
* :sparkles: mica-mqtt server IMqttMessageListener 不再强制要求实现。
* :sparkles: 使用 netty IntObjectHashMap 优化默认 session 存储。
* :sparkles: 添加 github action，用于自动构建开发阶段的 SNAPSHOT 版本。
* :sparkles: 示例项目拆分到 example 目录，mica-mqtt client、server starter 拆分到 starter 目录。
* :arrow\_up: 依赖升级.

### v1.2.10 - 2022-03-20

* :sparkles: mica-mqtt server 添加 MQTT 客户端 keepalive 系数 `keepalive-backoff`。
* :sparkles: mica-mqtt client、server 调整发布的日志级别为 debug。
* :sparkles: mica-mqtt client 优化 javadoc。
* :sparkles: mica-mqtt client 重连时，支持重新设置新的鉴权密码。

### v1.2.9 - 2022-03-06

* :sparkles: mqttServer#publishAll() 日志级别调整 gitee #I4W4IS
* :sparkles: @MqttClientSubscribe 支持 springboot 配置 gitee #I4UOR3
* :sparkles: mica-mqtt client 代码优化
* :sparkles: mica-mqtt-spring-boot-example 拆分

### v1.2.8 - 2022-02-20

* :sparkles: mica-mqtt server 优化连接 connect 日志。
* :sparkles: mica-mqtt server 代码优化。
* :sparkles: mica-mqtt server 添加 statEnable 配置，默认关闭，开启 Prometheus 监控，需要设置为 true。
* :sparkles: mica-mqtt client 添加 statEnable 配置，默认关闭。
* :sparkles: mica-mqtt client 优化默认线程池。

### v1.2.7 - 2022-02-13

* :sparkles: mica-mqtt-spring-boot-starter 完善。
* :sparkles: mica-mqtt client 考虑一开始就没有连接上服务端的情况。
* :sparkles: mica-mqtt client 添加 isConnected 方法
* :sparkles: mica-mqtt client、server connectListener 改为异步
* :sparkles: mica-mqtt server ChannelContext 添加用户名，使用 (String) context.get(MqttConst.USER\_NAME\_KEY) 获取。
* :sparkles: websocket ssl 配置
* :sparkles: 尝试新版 graalvm
* :bug: 修复多个 mica mqtt client 消息id生成器隔离。

### v1.2.6 - 2022-01-19

* :sparkles: mica-mqtt-client 支持 `$share`、`$queue` 共享订阅

### v1.2.5 - 2022-01-16

* :sparkles: mica mqtt server 调整发布权限规则。
* :sparkles: mica mqtt server 自定义接口的异常处理。
* :sparkles: mica mqtt server 放开 tio 队列配置。
* :sparkles: mica mqtt client publish 添加一批 byte\[] payload 参数方法。
* :sparkles: mica-mqtt-model DefaultMessageSerializer 重构，**不兼容**。
* :memo: 添加日志，避免遗忘。
* :bug: http websocket 都不开启并排除 tio-websocket-server 依赖时 gitee  #I4Q3CP

### v1.2.4 - 2022-01-09

* :fire: mica-mqtt-core 排除一些不需要的依赖。
* :fire: mica-mqtt-core http websocket 都不开启时，可以排除 tio-websocket-server 依赖。
* :sparkles: mica-mqtt-core MqttTopicUtil 改名为 TopicUtil。
* :sparkles: mica-mqtt-spring-boot-starter `@MqttClientSubscribe` 支持 IMqttClientMessageListener bean。
* :sparkles: mica-mqtt-spring-boot-starter `@MqttClientSubscribe` 支持自定义 MqttClientTemplate Bean。
* :sparkles: mica-mqtt-spring-boot-starter 完善。
* :sparkles: mica-mqtt-codec 缩短 mqtt 版本 key。
* :bug: mica-mqtt-codec 修复 will message。

### v1.2.3 - 2022-01-03

* :sparkles: mica-mqtt-spring-boot-starter `@MqttClientSubscribe` value 改为数组，支持同时订阅多 topic。
* :sparkles: mica-mqtt-core 缓存 TopicFilter Pattern。
* :sparkles: mica-mqtt-core 优化客户端和服务端订阅逻辑 `IMqttServerSubscribeValidator` 接口调整。
* :sparkles: mica-mqtt client 添加批量订阅。
* :sparkles: mica-mqtt client 添加批量取消订阅。
* :sparkles: mica-mqtt client 添加客户端是否断开连接。
* :sparkles: mica-mqtt client 客户端断开重新订阅时支持配置批次大小。
* :bookmark: mica-mqtt client 订阅 `IMqttClientMessageListener` 添加 `onSubscribed` 默认方法。
* :arrow\_up: mica-mqtt-example 升级 log4j2 到 2.17.1

### v1.2.2 - 2021-12-26

* :sparkles: mica-mqtt server 添加发布权限接口，无权限直接断开连接，避免高级别 qos 重试浪费资源。
* :sparkles: mica-mqtt-broker 优化节点信息存储
* :sparkles: mica-mqtt client 重复订阅优化。感谢 `@一片小雨滴`
* :sparkles: mica-mqtt client 抽象 IMqttClientSession 接口。
* :bug: 修复重构 AbstractMqttMessageDispatcher 保持跟 mica-mqtt-broker 逻辑一致 gitee #I4MA6A 感谢 `@胡萝博`
* :arrow\_up: mica-mqtt-example 升级 log4j2 到 2.17.0

### v1.2.1 - 2021-12-11

* :sparkles: mica-mqtt 优化 topic 匹配。
* :sparkles: mica-mqtt client disconnect 不再自动重连 gitee #I4L0WK 感谢 `@willianfu`。
* :sparkles: mica-mqtt client 添加 retryCount 配置 gitee #I4L0WK 感谢 `@willianfu`。
* :sparkles: mica-mqtt-model message 添加 json 序列化。
* :sparkles: mica-mqtt-broker 重新梳理逻辑。
* :bug: mica-mqtt-spring-boot-starter 在 boot 2.6.x 下 bean 循环依赖 gitee #I4LUZP 感谢 `@hongfeng11`。
* :bug: mica-mqtt server 同一个 clientId 踢出时清除老的 session。
* :bug: mica-mqtt server 集群下一个 clientId 只允许连接到一台服务器。
* :bug: mica-mqtt client 修复 IMqttClientConnectListener onDisconnect 空指针。
* :memo: mica-mqtt-model 添加 README.md

### v1.2.0 - 2021-11-28

* :sparkles: mqtt-mqtt-core client IMqttClientConnectListener 添加 onDisconnect 方法。gitee #I4JT1D 感谢 `@willianfu` 同学反馈。
* :sparkles: mica-mqtt-core server IMqttMessageListener 接口调整，不兼容老版本。
* :sparkles: mica-mqtt-broker 调整上下行消息通道。
* :sparkles: mica-mqtt-broker 添加节点管理。
* :sparkles: mica-mqtt-broker 调整默认的 Message 序列化方式，不兼容老版本。
* :sparkles: mica-mqtt-broker 优化设备上下线，处理节点停机的情况。
* :sparkles: 抽取 mica-mqtt-model 模块，方便后期支持消息桥接，Message 添加默认的消息序列化。 gitee #I4ECEO
* :sparkles: mica-mqtt-model 完善 Message 消息模型，方便集群。
* :bug: mica-mqtt-core MqttClient 修复 ssl 没有设置，感谢 `@hjkJOJO` 同学反馈。
* :bug: 修复 websocket mqtt.js 需要拆包 gitee #I4JYJX 感谢 `@Symous` 同学反馈。
* :memo: 完善 mica-mqtt-broker README.md，添加二开说明。
* :memo: 统一 mica-mqtt server ip 文档。
* :memo: 更新 README.md
* :arrow\_up: 升级 tio 到 3.7.5.v20211028-RELEASE AioDecodeException 改为 TioDecodeException，

### v1.1.4 - 2021-10-16

* :sparkles: 添加 uniqueId 概念，用来处理 clientId 不唯一的场景。详见：gitee #I4DXQU
* :sparkles: 微调 `IMqttServerAuthHandler` 认证，添加 uniqueId 参数。

### v1.1.3 - 2021-10-13

* :sparkles: 状态事件接口 `IMqttConnectStatusListener` 添加 ChannelContext 参数。
* :sparkles: 从认证中拆分 `IMqttServerSubscribeValidator` 订阅校验接口，添加 ChannelContext、clientId 参数。
* :sparkles: 认证 `IMqttServerAuthHandler` 调整包、添加 ChannelContext 参数。
* :sparkles: 完善文档和示例，添加默认端口号说明。
* :arrow\_up: 依赖升级

### v1.1.2 - 2021-09-12

* :sparkles: 添加 mica-mqtt-broker 模块，基于 redis pub/sub 实现 mqtt 集群。
* :sparkles: mica-mqtt-broker 基于 redis 实现客户端状态存储。
* :sparkles: mica-mqtt-broker 基于 redis 实现遗嘱、保留消息存储。
* :sparkles: mqtt-server http api 调整订阅和取消订阅，方便集群处理。
* :sparkles: mica-mqtt-spring-boot-example 添加 mqtt 和 http api 认证示例。
* :sparkles: 添加 mqtt 5 所有 ReasonCode。
* :sparkles: 优化解码 PacketNeededLength 计算。
* :bug: 修复遗嘱消息，添加消息类型。
* :bug: 修复 mqtt-server 保留消息匹配规则。

### v1.1.1 - 2021-09-05

* :sparkles: mqtt-server 优化连接关闭日志。
* :sparkles: mqtt-server 优化订阅，相同 topicFilter 订阅对 qos 判断。
* :sparkles: mqtt-server 监听器添加 try catch，避免因业务问题导致连接断开。
* :sparkles: mqtt-server 优化 topicFilters 校验。
* :sparkles: mqtt-client 优化订阅 reasonCodes 判断。
* :sparkles: mqtt-client 监听器添加 try catch，避免因业务问题导致连接断开。
* :sparkles: mqtt-client 添加 session 有效期。
* :sparkles: 代码优化，减少 codacy 上的问题。
* :bug: mqtt-server 修复心跳时间问题。
* :bug: 修复 mqtt-server 多个订阅同时匹配时消息重复的问题。
* :bug: mqtt-client 优化连接处理的逻辑，mqtt 连接之后再订阅。
* :bug: 修复 MqttProperties 潜在的一个空指针。

### v1.1.0 - 2021-08-29

* :sparkles: 重构，内置 http，http 和 websocket 公用端口。
* :sparkles: 添加 mica-core 中的 HexUtil。
* :sparkles: 添加 PayloadEncode 工具。
* :sparkles: ServerTioConfig#share 方法添加 groupStat。
* :sparkles: 考虑使用 udp 多播做集群。
* :sparkles: MqttServer、MqttServerTemplate 添加 close、getChannelContext 等方法。
* :sparkles: 重构 MqttServerConfiguration 简化代码。
* :sparkles: 配置项 `mqtt.server.websocket-port` 改为 `mqtt.server.web-port`。
* :memo: 添加 JetBrains 连接。
* :bug: 修复默认的消息转发器逻辑。
* :bug: 修复 websocket 下线无法触发offline gitee #I47K13 感谢 `@willianfu` 同学反馈。

### v1.0.6 - 2021-08-21

* :sparkles: 添加订阅 topicFilter 校验。
* :sparkles: 优化压测工具，更新压测说明，添加 tcp 连接数更改文档地址。
* :sparkles: mica-mqtt-example 添加多设备交互示例。
* :sparkles: 优化 mica-mqtt-spring-boot-example。
* :sparkles: 优化 deploy.sh 脚本。
* :bug: 优化解码异常处理。
* :bug: 修复心跳超时处理。
* :arrow\_up: 升级 spring boot 到 2.5.4

### v1.0.5 - 2021-08-15

* :bug: 修复编译导致的 java8 运行期间的部分问题，NoSuchMethodError: java.nio.ByteBuffer.xxx

### v1.0.3 - 2021-08-15

* :sparkles: mica-mqtt server 添加 websocket mqtt 子协议支持（支持 mqtt.js）。
* :sparkles: mica-mqtt server ip，默认为空，可不设置。
* :sparkles: mica-mqtt client去除 CountDownLatch 避免启动时未连接上服务端卡住。
* :sparkles: mica-mqtt client 添加最大包体长度字段，避免超过 8092 长度的包体导致解析异常。
* :sparkles: mica-mqtt client 添加连接监听 IMqttClientConnectListener。
* :sparkles: mica-mqtt 3.1 协议会校验 clientId 长度，添加配置项 maxClientIdLength。
* :sparkles: mica-mqtt 优化 mqtt 解码异常处理。
* :sparkles: mica-mqtt 日志优化，方便查询。
* :sparkles: mica-mqtt 代码优化，部分 Tio.close 改为 Tio.remove。
* :sparkles: mica-mqtt-spring-boot-example 添加 Dockerfile，支持 `spring-boot:build-image`。
* :sparkles: 完善 mica-mqtt-spring-boot-starter，添加遗嘱消息配置。
* :arrow\_up: 升级 t-io 到 3.7.4。

### v1.0.3-RC - 2021-08-12

* :sparkles: 添加 websocket mqtt 子协议支持（支持 mqtt.js）。
* :sparkles: mqtt 客户端去除 CountDownLatch 避免启动时未连接上服务端卡住。
* :sparkles: mica-mqtt 服务端 ip，默认为空，可不设置。
* :sparkles: 完善 mica-mqtt-spring-boot-starter，添加遗嘱消息配置。
* :sparkles: mqtt 3.1 协议会校验 clientId 长度，添加设置。
* :sparkles: mqtt 日志优化，方便查询。
* :sparkles: 代码优化，部分 Tio.close 改为 Tio.remove。
* :arrow\_up: 升级 t-io 到 3.7.4。

### v1.0.2 - 2021-08-08

* :memo: 文档添加集群处理步骤说明，添加遗嘱消息、保留消息的使用场景。
* :sparkles: 去除演示中的 qos2 参数，性能损耗大避免误用。
* :sparkles: 遗嘱、保留消息内部消息转发抽象。
* :sparkles: mqtt server 连接时先判断 clientId 是否存在连接关系，有则先关闭已有连接。
* :sparkles: 添加 mica-mqtt-spring-boot-example 。感谢 wsq（ @冷月宫主 ）pr。
* :sparkles: mica-mqtt-spring-boot-starter 支持客户端接入和服务端优化。感谢 wsq（ @冷月宫主 ）pr。
* :sparkles: mica-mqtt-spring-boot-starter 服务端支持指标收集。可对接 `Prometheus + Grafana` 监控。
* :sparkles: mqtt server 接受连接时，先判断该 clientId 是否存在其它连接，有则解绑并关闭其他连接。
* :arrow\_up: 升级 mica-auto 到 2.1.3 修复 ide 多模块增量编译问题。

### v1.0.2-RC - 2021-08-04

* :sparkles: 添加 mica-mqtt-spring-boot-example 。感谢 wsq（ @冷月宫主 ）pr。
* :sparkles: mica-mqtt-spring-boot-starter 支持客户端接入和服务端优化。感谢 wsq（ @冷月宫主 ）pr。
* :sparkles: mica-mqtt-spring-boot-starter 服务端支持指标收集。可对接 `Prometheus + Grafana` 监控。
* :sparkles: mqtt server 接受连接时，先判断该 clientId 是否存在其它连接，有则解绑并关闭其他连接。

### v1.0.1 - 2021-08-02

* :sparkles: 订阅管理集成到 session 管理中。
* :sparkles: MqttProperties.MqttPropertyType 添加注释，考虑 mqtt V5.0 新特性处理。
* :sparkles: 添加 Spring boot starter 方便接入，兼容低版本 Spring boot。
* :sparkles: 调研 t-io websocket 子协议。
* :bug: 修复 java8 运行期间的部分问题，NoSuchMethodError: java.nio.ByteBuffer.xxx

### v1.0.1-RC - 2021-07-31

* :sparkles: 添加 Spring boot starter 方便接入。
* :sparkles: 调研 t-io websocket 子协议。

### v1.0.0 - 2021-07-29

* :sparkles: 基于低延迟高性能的 t-io AIO 框架。
* :sparkles: 支持 MQTT v3.1、v3.1.1 以及 v5.0 协议。
* :sparkles: 支持 MQTT client 客户端。
* :sparkles: 支持 MQTT server 服务端。
* :sparkles: 支持 MQTT 遗嘱消息。
* :sparkles: 支持 MQTT 保留消息。
* :sparkles: 支持自定义消息（mq）处理转发实现集群。
* :sparkles: 支持 GraalVM 编译成本机可执行程序。

---

---
url: /version/update.md
---
# mica-mqtt 升级指南
**mica-mqtt** 尽量减少对 api 的改动已保证老版本的平滑升级，但是有些大版本不得不改动。希望此文档对大家有所帮助。

## 迁移到 mica-mqtt 2.4.2

注意：2.4.2 将 MqttServerCustomizer 和 MqttClientCustomizer 抽到 mica-mqtt-server、mica-mqtt-client。Spring Boot 和 Solon 插件如果有使用到，请先将老的包导入删除，idea 会自动引入新的包。

**客户端替换包导入：**

* 替换成 `import org.dromara.mica.mqtt.core.client.MqttClientCustomizer;`

**服务端替换包导入：**

* 替换成 `import org.dromara.mica.mqtt.core.server.MqttServerCustomizer;`

## 老版本迁移到 dromara 社区 mica-mqtt 2.4.x 以上版本

* :truck: 调整 maven groupId `net.dreamlu` 到新的 `org.dromara.mica-mqtt`。
* :truck: 调整包名 `net.dreamlu.iot.mqtt` 到新的 `org.dromara.mica.mqtt`，其他均保持不变。
* :truck: 切换到 central sonatype，central sonatype 不支持快照版，mica-mqtt 不再发布快照版。

## 老版本迁移到 mica-mqtt 2.1.x

* `mica-mqtt-core` 拆分成了 `mica-mqtt-client` 和 `mica-mqtt-server`，避免一些依赖引用问题。
* `ByteBufferUtil` 由 `org.dromara.mica.mqtt.codec.ByteBufferUtil` 移动到了 `org.tio.utils.buffer.ByteBufferUtil`。
* `HexUtil` 由 `org.dromara.mica.mqtt.core.util.HexUtil` 移动到了 `org.tio.utils.mica.HexUtils`。

### 1. 客户端

#### 1.1 订阅回调接口调整

注意：`mica-mqtt-client-spring-boot-starter` 使用注解订阅可以直升。

`IMqttClientMessageListener#onMessage(ChannelContext context, String topic, MqttPublishMessage message, ByteBuffer payload)` 方法统一添加 `context`、`message` 参数。

订阅系列方法需要调整：

```java
// 消息订阅，同类方法 subxxx
client.subQos0("/test/#", (context, topic, message, payload) -> {
    logger.info(topic + '\t' + ByteBufferUtil.toString(payload));
});
```

#### 1.2 SSL 双向认证支持

```yaml
mica:
  client:
    ssl:
      enabled: false            # 是否开启 ssl 认证，2.1.0 开始支持双向认证
      keystore-path:            # 可选参数：ssl 双向认证 keystore 目录，支持 classpath:/ 路径。
      keystore-pass:            # 可选参数：ssl 双向认证 keystore 密码
      truststore-path:          # 可选参数：ssl 双向认证 truststore 目录，支持 classpath:/ 路径。
      truststore-pass:          # 可选参数：ssl 双向认证 truststore 密码
```

注意： ssl 存在三种情况

| 服务端开启ssl                            | 客户端                                        |
| ---------------------------------------- | --------------------------------------------- |
| ClientAuth 为 NONE（不需要客户端验证）   | 仅仅需要开启 ssl 即可不用配置证书             |
| ClientAuth 为 OPTIONAL（与客户端协商）   | 需开启 ssl 并且配置 truststore 证书           |
| ClientAuth 为 REQUIRE (必须的客户端验证) | 需开启 ssl 并且配置 truststore、 keystore证书 |

### 2. 服务端

#### 2.1 IMqttMessageListener 调整

`IMqttMessageListener` onMessage 参数也做了调整，添加了 topic、qoS，message 改为了原始 MqttPublishMessage，方便自行获取 mqtt5.x 的属性。

```java
/**
 * 监听到消息
 *
 * @param context  ChannelContext
 * @param clientId clientId
 * @param topic    topic
 * @param qoS      MqttQoS
 * @param message  Message
 */
void onMessage(ChannelContext context, String clientId, String topic, MqttQoS qoS, MqttPublishMessage message);
```

#### 2.2 ssl 双向认证支持

```yaml
mica:
  server:
    ssl:                        # mqtt tcp ssl 认证
      enabled: false            # 是否开启 ssl 认证，2.1.0 开始支持双向认证
      keystore-path:            # 必须参数：ssl keystore 目录，支持 classpath:/ 路径。
      keystore-pass:            # 必选参数：ssl keystore 密码
      truststore-path:          # 可选参数：ssl 双向认证 truststore 目录，支持 classpath:/ 路径。
      truststore-pass:          # 可选参数：ssl 双向认证 truststore 密码
      client-auth: none         # 是否需要客户端认证（双向认证），默认：NONE（不需要）
```
